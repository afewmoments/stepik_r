---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Модуль 1 --- базовые структуры и понятия

```{r}
library(tidyverse)
library(randtoolbox)
```

## 1.3 Векторы (часть 1)

Перед тем как создавать функцию, пробуем сделать в рабочем окружении. 

Сначала я попробовал функцию `rev()`, но она сортирует в пределах одного вектора:

```{r}
m <- 3
n <- 7
f1 <- seq(0, 1, by = 1/m)
f2 <- seq(0, 1, by = 1/n)
w <- c(f1, f2)
r <- rev(w)
unique(r)
```

Поэтому лучше использовать функцию `sort()`, она сортирует более привычным способом 

```{r}
m <- 3
n <- 7
f1 <- seq(0, 1, by = 1/m)
f2 <- seq(0, 1, by = 1/n)
w <- c(f1, f2)
r <- sort(w)
unique(r)
```

Теперь всё работает. Можно переходить к намписанию функции

```{r}
get_fractions <- function(m, n) {
x <- seq(0, 1, by = 1/m)
y <- seq(0, 1, by = 1/n)
return(unique(sort(c(x, y), decreasing = TRUE)))
}
get_fractions(3, 7)
```

## 1.4 Управляющие конструкции, работа с пакетами

### Циклы `if`, `else`, `ifelse`

Переносить `else` на другую строку от курвы нельзя.

Если число больше 1.5 напечатай Yammi, иначе напечатай Less

```{r}
if (sqrt(2) > 1.5) {
  print("Yammi")
} else {
  print("Less")
}
```

Если число больше 0.5 выведи Орёл, иначе Решка
```{r}
runif(8)      # Рандомное число от 0 до 1
ifelse(runif(8) > 0.5, "Орёл", "Решка")
```

### Циклы `repeat`

для каждого числа повтори прибавление к этому числу рандомного (от 0 до 1) и выведи на печать, если число больше пяти остановись

```{r}
i <- 0
repeat {
  i <- i + runif(1)
  print(i)
  if (i > 5) break
}
```

### Циклы `while`

Пока число больше 1000 раздели это число пополам и выведи на печать
```{r}
i <- 2^14
while (i > 1000) {
  i <- i/2
  print(i)
}
```

### Циклы `for`

Для каждого `i` в диапазоне от 1 до 8, если остаток от деления числа равен нулю выведи число на печать
```{r}
for (i in 1:8) {
  if (i %% 2 == 0) print(i)
}
```

### Задача 1

Если утверждение верное, поставьте галочку. Впрочем, это лишняя информация, смысл задания и так понятен.


F Синтаксис цикла for зависит от типа вектора в условии.
T ifelse -- это векторизованный вариант if.
F В цикле if можно переносить условие else на новую строку.
T Не стоит использовать цикл for, если есть возможность использовать векторизацию.
F %% -- это оператор целочисленного деления (integer division).

### Задача 2

```{r}
set.seed(1337)
x <- runif(1e6, min = -1, max = 1)
```

Теперь в вашем распоряжении вектор x длиной один миллион. Мне крайне интересно, сколько среди них чисел в диапазоне (-0.2, 0.3). Для определённости не включая границы интервала. Впрочем, кто знаком с теорией вероятностей, тот знает, что это уточнение несущественно.

```{r}
sum(between(x, -0.2, 0.3))
```

### Задача 3

Вам не нравятся ни монетка, ни "камни-ножницы-бумага"? Хорошо, давайте играть в "Монополию", только у меня нет кубика. Напишите его сами!

Функция `dice_roll(n)` должна выдавать n независимых бросков игрального кубика. Допустимые значения, разумеется, в диапазоне от 1 до 6.

Только учтите, что если кубик нечестный (не все грани выпадают с равной вероятностью), я это проверю и играть с вами не сяду!


Для генерации бросков будем использовать функцию `sample()`. Хэлп по ней всё расставит на свои места


```{r}
dice_roll <- function(n) {
x <- sample(1:6, n, replace = TRUE)
  return(x)
}

ggplot() + aes(dice_roll(1000))+ geom_histogram(binwidth=1, colour="black", fill="white")
sessionInfo()
```

## 1.5 Векторы (Часть 2)

```{r}
x <- seq(10, 100, 10)

x[c(1, 2, 4)]

x[rep(c(T,F), 5)]
```

```{r}

```

Функция `all` и `any`

```{r}
all(x < 200); all(x > 200)
```

Функция `which` --- если нас интересует позиции

```{r}
which(x <= 100)
```


### Задача 1

Пусть имеется вектор `x` произвольного типа. Какая конструкция может быть использована, чтобы получить содержимое вектора x без каждого седьмого элемента?
P.S. Давайте предполагать, что понятие "каждый седьмой" имеет смысл, то есть элементов в векторе хотя бы семь.

```{r}
x <- seq(1, 10, 1)
```

```{r}
x[c(rep(T, 6), F)]
x[-(seq(7, length(x), by = 7))]
x[-(seq(7, length(x), by = 7))]
x[1:length(x) %% 7 > 0]
x[-(1:floor(length(x)/7) * 7)]
x[1:length(x) %% 7 != 0]
```


```{r}
max(c(TRUE, FALSE))
which(c("A", "BBB", "Z"))
22:19
c("A", "BBB", "Z")
c("1", "99", "HI")
c(TRUE, FALSE)

x <- c(1:4, 11)
which.max(x)

x <- rep(1, 10); length(max(x)); length(which.max(x)); length(x == 1)

max(c("A", "BBB", "Z"))
max(c("1", "99", "HI"))
which.max(c("1", "100", "99"))
```

### Задача 2

```{r}
x <- c(1, 23, 5, 19, 15, 13, 5)
letters[x]
```

### Задача 3

Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает `TRUE`, если вектор обладает свойством нестрогой монотонности, то есть является либо несторого возрастающим, либо нестрого убывающим. В противном случае функция возвращает `FALSE`.

```{r}
is_monotone <- function(x){
  if (all(x[-1] - x[-length(x)] >= 0)) {
    return(TRUE)
  } else {
  if (all(x[-1] - x[-length(x)] <= 0)) {
    return(TRUE)
  }  else {
    return(FALSE)
  }
  }
}

x <- c(0, 0, 3, 4, 4, 8)
y <- rep(0, 10)
z <- c(10:1)
n <- c(0, 0, 3, 2, 4, 8)

is_monotone(x)
is_monotone(z)
is_monotone(y)
is_monotone(n)
```


### Задача 4

Пусть у нас есть `n` предметов, из которых нужно выбрать `k` штук.

Известнейшая комбинаторная формула $$C_{n}^k = \frac{n!}{k!(n−k)!}$$ ("Цэ из эн по ка") задаёт количество всевозможных сочетаний. Похожий вид имеет и количество сочетаний с повторениями (мультикомбинаций).

Запрограммируйте оба этих значения в виде функции, зависящей от `n` и `k`. Аргумент `with_repetitions` будет отвечать за вариант подсчёта: если он `FALSE`, то пусть считается количество сочетаний, а если `TRUE`, то сочетаний с повторениями.

```{r}
combin_count <- function(n, k, with_repretitions = FALSE) {
if(with_repretitions == FALSE) {
  return(factorial(n) / (factorial(k) * factorial(n-k)))
} else {
  return(factorial(n+k-1) / (factorial(k) * factorial(n-1)))
}
}

n <- 5
k <- 3
factorial(20)

combin_count(5, 3)
factorial(5) # 120
factorial(3) # 6
factorial(2) # 2

```

# Модуль 2 --- продвинутые структуры

## Матрицы и списки ч1

Матрица --- двумерный массив данных одного типа

```{r}
matrix(1:6, nrow = 2, ncol = 3)
```

```{r}
matrix(1:6, nrow = 2)
```

```{r}
matrix(1:6, nrow = 2, byrow = T)
```

Чтобы прочекать размерность, можно использовать функцию `dim` 

```{r}
m <- matrix(1:6, ncol = 3)
dim(m)
```

Арифметические операции --- действуют поэлментно

```{r}
m1 <- matrix(1:4, nrow = 2)
m2 <- matrix(c(1, 2, 2, 3), nrow = 2)

m1 + m2

m1 + 5
```

Умножение по правилам линейной алгебры

```{r}
m1 %*% m2
```

Вот немного [материала по этой теме](http://mathhelpplanet.com/static.php?p=umnozhenie-matrits)

И ещё  [схема умножения](img\matrix.png)

Индексирование --- так же как для векторово

```{r}
m <- matrix(1:10, ncol = 5)
m[1,3]
```


Обнулить всю первую строчку

```{r}
m[1, ] <- 0; m
```

Переприсвоить все столбцы кроме пятого

```{r}
m[, -5] <- 11:18; m
```

Схлопывание размерности. Даём в индексах вектор --- получаем в ответ матрицу

```{r}
m <- matrix(1:10, ncol = 5)
ind <- c(1, 3, 5)
m[, ind]
```

Даём в индексе число --- получаем в ответ вектор
```{r}
ind <- 3
m[, ind]
```

Схлопыванием размерности можно управлять параметром `drop`. Установив `FALSE` на выдаче получим матрицу

```{r}
m[, ind, drop = F]
```

Именование матриц можно делать при помощи функций 
`rownames()` и `colnames()`.

```{r}
m <- matrix(1:10, ncol = 5)
rownames(m) <- c("row1", "row2")
colnames(m) <- paste0("column", 1:5)
# Теперь можно обращаться по именам столбцов
```

`paste0` --- склеивает аргументы в вектор строк. 

Применение функций к матрице. `apply()`

```{r}
m <- matrix(1:25, 5)
f <- function(x) sum(x^2)
```

Функция `apply()` проходит по столбцам или строкам.

```{r}
apply(m, 2, f)
```

Можно применять и ко всей матрице, если вторым аргументом подавать вектор.

```{r}
apply(m, 1:2, function(i) if (i>13) i else 13)
```

Но тоже самое можно сделать при помощи __анонимной функции__. Она не имеет имени. Для этого воспользуемся матричным индексированием

```{r}
m[m <= 13] <- 13; m
```

Те элементы матрицы которые меньше тринадцати --- замени на 13

### Задача 1

```{r}
m <- 5
n <- 2
mat <- matrix(1:10, m, n)
mat[m, n] # Вектор длины 1, содержащий элемент в правом нижнем углу
# mat[n, m] # ошибочная запись: ошибки не будет только при m=n
mat[m, ] # Вектор, содержащий строку номер m
mat[m, , drop = FALSE] # Вектор, содержащий строку (ряд) номер m
mat[, n, drop = F] # Матрица, состоящая из одного столбца (колонки) номер n
mat[, n, drop = TRUE] # Вектор, содержащий столбец (колонку) номер n
mat > 5 # Вектор, содержащий столбец (колонку) номер n
mat[mat > 5] # Вектор, содержащий все значения по условию (возможно, пустой)
```

### Задача 2

Предположим, что у нас есть целочисленный вектор `v` и число `n`. Наша задача — найти позицию элемента в векторе, который ближе всего к числу `n`. При этом если таких элементов несколько, необходимо указать все позиции.

Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. Индексы должны быть выстроены по возрастанию.

Пример. Пусть `v <- c(5, 2, 7, 7, 7, 2, 0, 0)` и `n=1`. Ответом будет вектор

```{r}
n <- 5
v <- c(5, 2, 7, 7, 7, 2, 0, 0)

Mod(v - n)

Mod(min(v - n))

which(Mod(v - n) == n)

min(Mod(v - n))

which(Mod(v - n) == min(Mod(v - n)))

```


```{r}
find_closest <- function(v, n) {
which(Mod(v - n) == min(Mod(v - n)))
}
```

## Матрицы и списки ч2

Предположим нам необходимо соединить две матрица диагональным способом. То есть нам необходимо получить матрицу `m3` в которой левый верхний угол это матрица `m1`, а правый нижний угол это матрица `m2`, а остальные элементы заполнены какими-то значениями `fill`.

```{r}
bian_diag <- function(m1, m2, fill) {
  m3 <- matrix(fill, 
               nrow = nrow(m1) + nrow(m2),
               ncol = ncol(m1) + ncol(m2))
  m3[1:nrow(m1), 1:ncol(m1)] <- m1
  m3[nrow(m1) + 1:nrow(m2), ncol(m1) + 1:ncol(m2)] <- m2
  m3
}
```

```{r}
m1 <- matrix(1:12, nrow = 3)
m2 <- matrix(10:15, nrow = 3)
bian_diag(m1, m2, fill = 0)
```

### Задача 3

Напишите функцию, которая принимает одно целое число `n`, а возвращает “ступенчатую” матрицу, состоящую из `n` этажей. Этажи нумеруются с первого, ширина каждой ступеньки равна одной строке или столбцу.

Пример. Пусть `n=4`, тогда необходимо вернуть матрицу вида

  1   1   1   1   1   1   1
  1   2   2   2   2   2   1
  1   2   3   3   3   2   1
  1   2   3   4   3   2   1
  1   2   3   3   3   2   1
  1   2   2   2   2   2   1
  1   1   1   1   1   1   1

Сначала я решил задачу без функции, для частного случая из примера

```{r}
# Завёл вектор с длиной максимального элемента, который стоит в середине
v <- c(1:4)

# Построил из вектора матрицу 
n <- matrix(v, length(v), length(v), byrow = T)

# Привёл матрицу к нужному числу строк и столбцов
m <- n[c(v, 3:1),c(v, 3:1)]


# Заменил нужные элементы матрицы на необходимые
m[c(1, 7), c(1:7)] <- 1
m[c(2, 6), c(2:6)] <- 2
m[c(3, 5), c(3:5)] <- 3
m
```

После того как задача была решена для частного случая, я стал разбираться как сделать то же самое в общем случае.

```{r}
build_ziggurat <- function(n) {
  # Сразу указываю частный случай для матрицы размерностью 1
  if(n <= 1) {
    return(matrix(1, 1, 1))
    } else {
    # Задаю два вектора определяющие размерность матрицы
    len <- seq(1, n, 1)
    rot <- seq(n-1, 1, -1)
    # Построил из вектора матрицу
    mat <- matrix(len, length(len), length(len), byrow = T)
    # Привожу матрицу к нужному числу строк и столбцов
    done <- mat[c(len, rot),c(len, rot)]
    # В цикле говорю - замени все указанные позиции в матрице, на элементы из вектора меньшей размерности
    for (i in rot) {
      pre <- seq(i, (length(len) + length(rot)) - i + 1, 1)
      done[c(i, max(pre)), pre] <- i
      }
    return(done)
    }
}

build_ziggurat(1)
build_ziggurat(4)
build_ziggurat(7)

```

Вариант из решений. Чуть короче и интереснее

```{r}
build_ziggurat <- function(n) {
  mtrx <- matrix(1, n, n)
  for (i in 1:n) {
    mtrx[i:nrow(mtrx), i:ncol(mtrx)] <- i
  }
  mtrx <- rbind(mtrx, mtrx[rev(seq_len(nrow(mtrx)-1)), ])
  mtrx <- cbind(mtrx, mtrx[, rev(seq_len(ncol(mtrx)-1))])
  mtrx
}
```

Без цикла:

```{r}
build_ziggurat <- function(n) {
    m <- matrix(1, ncol=n*2 - 1, nrow=n*2 - 1)
    if(n > 1) m[2:(n*2-2), 2: (n*2-2)] <- m[2:(n*2-2), 2: (n*2-2)] + build_ziggurat(n-1)
    m
}
```



### Создание списков

```{r}
list(a = 1, b = 1:3, "1to5" = 1:5, 42)
```

Рекурсивный список:

```{r}
list(a = list(1, 2, 3), b = list(list(4), 5, 6))
```

Конкатенация списков

```{r}
l1 <- list(name = "john", salary = 1000)
l2 <- list(has_car = TRUE, car = "volga")
c(l1, l2)
```

Любой вектор можно свести к списку. Но не наоборот

```{r}
v <- c(1:10)
m <- matrix(v, length(v), length(v), byrow = T)

# возвращаемое значение -- единичная матрица указанного размера
diag(4) 

# возвращаемое значение -- диагональная матрица с указанными элементами на диагонали
diag(1:4)

# возвращаемое значение -- вектор, содержащий диагональные элементы
diag(m)

```

Функция возвращает все вектора из списка максимальной длины:

```{r}
get_longest <- function(l){
  len <- sapply(l, length)
  ind <- which(len == max(len))
  list(number = ind, element = l[ind])
}

# Тестирование. Для этого делаем функцию.

gen_list <- function(n_elements, max_len, seed = 111) {
  set.seed(seed)
  len <- sample(1:max_len, n_elements)
  lapply(len, rnorm)
}

l1 <- gen_list(4, 10)
get_longest(l1)



```


### Задача 4

Парижане бунтуют! По слухам, Бастилия плохо охраняется, а её арсеналы полны пороха и мушкетов.
Пришло время решительных действий. Наши агенты смогли подсчитать количество солдат в патрулях в каждой из восьми башен крепости. Вот эти данные:

```{r}
set.seed(1789)
bastille <- list(
  "La Chapelle Tower" = rbinom(5, 10, 1/2), 
  "Tresor Tower" = rbinom(8, 12, 1/4), 
  "Comte Tower" = rbinom(14, 3, 1/5) + 1,
  "Baziniere Tower" = rbinom(8, 4, 4/5), 
  "Bertaudiere Tower" = rbinom(4, 8, 2/3),
  "Liberte Tower" = rbinom(1, 100, 0.1), 
  "Puits Tower" = rbinom(5, 5, 0.7),
  "Coin Tower" = rbinom(3, 16, 0.4)
)

count(bastille)
get_longest(bastille)

# Лентяй
sum(unlist(bastille[1])) +
sum(unlist(bastille[2])) +
sum(unlist(bastille[3])) +
sum(unlist(bastille[4])) +
sum(unlist(bastille[5])) +
sum(unlist(bastille[6])) +
sum(unlist(bastille[7])) +
sum(unlist(bastille[8]))

```


### Задача 5

Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. В первой строке перечислите все различные элементы вектора, упорядоченные по возрастанию. Во второй строке укажите частоты (количество повторов) этих элементов.

Пример. Пусть `x <- c(5, 2, 7, 7, 7, 2, 0, 0)`. Тогда функция должна вернуть матрицу 2х4 с элементами

0 2 5 7
2 2 1 3


```{r}
x <- c(5, 2, 7, 7, 7, 2, 0, 0)

r <- matrix(as.matrix(as.data.frame(table(x))), nrow = 2, byrow = T)

forceMatrixToInteger <- function(m){
    apply (m, c (1, 2), function (x) {
         (as.integer(x))
    })
}

forceMatrixToInteger(r)
# Господи ну и монстр
# УФф, это работает, но надо разобраться в этом

# Проще всего это делается вот такщ
count_elements <- function(x) {
rbind(sort(unique(x)),table(x))
}
```

## Data frame

### Создание

```{r}
df <- data.frame(x = 1:4, y = LETTERS[1:4], z = c(TRUE, FALSE))

str(df)
```

### ДОбавление имён

```{r}
df <- data.frame(x = 1:4, y = LETTERS[1:4], z = c(TRUE, FALSE),
                 row.names = c("FK", "SL", "EJ", "SE"))
rownames(df)
colnames(df)
```

### Размерности

```{r}
nrow(df)
ncol(df)
```

Две важные особенности

* `length()` возвращает кол-во столбцов, а не общее кол-во переменных
```{r}
length(df)
```

* `names()`  возвращает имена столбцов

```{r}
names(df)
```


### Индексация 

как для матрицы

```{r}
df[3:4, -1]
```


### Фильтрация по условию

```{r}
df[df$x > 2, ]
```

```{r}
subset(df, x > 2)
```

```{r}
subset(df, x > 2, select = c(x, z))
```

### Комбинирование data frame-ов

Функции `rbind()` и `cbind()` работают как для матриц

```{r}
rbind(df, data.frame(x = 5:6, y = c("k", "l"), z = TRUE, row.names = c("Kappa", "Zulu")))
```


```{r}
cbind(df, data.frame(season = c("Summer", "winter", "autumn", "Spring"), temp = c(20, 15, 2, 5)))
```

### Комбинирование data frame-ов джоинами

```{r}
attitude %>%
  mutate(sum = complaints + raises + advance,
         num = 1:30) %>%
  arrange(desc(learning)) %>%
  head(5) %>%
  arrange(desc(sum)) %>%
  head(1) %>%
  select(num)
```

```{r}
subset(attitude, learning > 70)
```

### Импорт данных

```{r}
attitude[attitude$rating < 50, -"rating"]
subset(attitude, rating < 50, -rating)
attitude[rating < 50, names(attitude) != "rating"]
attitude[attitude$rating < 50, names(attitude) != "rating"]
subset(sel = -rating, sub = rating < 50, attitude)
```


```{r}
quakes %>% View()
summary(quakes)
?quakes
```

#### Задача
Доцент кафедры прикладного анализа данных Арчибальд Нелёгких проделал ту же работу над массивом avianHabitat, что и мы, и отправил результаты учёным из Аляски. Сегодня утром он обнаружил в почтовом ящике письмо следующего содержания.

Дорогой Арчи!
Получил твои расчёты. Твой вопрос относительно покрытия растительностью действительно обоснован: общее покрытие в самом деле достаточно низкое. Ты ведь не забыл, что мы работаем в Аляске? Смотри сам (фото справа):
http://minerals.usgs.gov/alaska/economic/sewpen.html
Ладно, слушай, у меня к тебе ещё одна просьба. У нас тут стажёр из аспирантуры работает, зовут его Карлош Линнейес или как-то так. В общем, он забыл прикрепить свои измерения к общему файлу. Ты не мог бы принять его кусок данных, прикрепить его к общему массиву и пересчитать показатели?
Только имей в виду: этот аспирант рассеянный тип, наверняка он что-нибудь напортачил. Впрочем, для тебя это наверняка пустяки! Файл avianHabitat2.csv прикрепляю.
Заранее спасибо!
Дж.


Помогите Арчибальду! Cкачайте файл по ссылке, добавьте новые данные в общий дата фрейм и повторите подсчёт общего покрытия, добавив переменную total_coverage. В качестве ответа пришлите величину среднего покрытия с точностью до второго знака: X.XX 

```{r}
library(tidyverse)
avianHabitat <- read_csv("https://raw.githubusercontent.com/tonytonov/Rcourse/master/R%20programming/avianHabitat.csv")

avianHabitat2 <- read_delim("https://raw.githubusercontent.com/tonytonov/Rcourse/master/R%20programming/avianHabitat2.csv", delim = ";", skip = 5, comment = " %", na = c("Don't remember", "NA"))

avianHabitat2 <- avianHabitat2 %>% 
  mutate(Observer = NA)

avian <- rbind(avianHabitat, avianHabitat2)

names(avian)
coverage_variables <- names(avian)[-(1:4)][c(T, F)]
avian$total_coverage <- rowSums(avian[, coverage_variables])
mean(avian$total_coverage)
```

#### Задача 2

Растительность Аляски, как мы уже знаем, достаточно скудна. Исследователям интересно, какие выдающиеся экземпляры растений удалось обнаружить? На массиве avianHabitat найдите максимальные высоты по каждому виду растений и отсортируйте эти виды по убыванию, от самого высокого к самому низкому.

```{r}
result <- avianHabitat %>% 
  summarise(A = max(AHt),
            DB = max(DBHt),
            L = max(LHt),
            E = max(EHt),
            H = max(HHt),
            W = max(WHt))

t(result)
```

## Факторы и строки

```{r}
v <- ("Аэрофотосъёмка ландшафта уже выявила земли богачей и процветающих крестьян.")
length(v)
sum(v)
nchar(v)
str_length(v)
strsplit
```

### Задача

```{r}
library(stringr)

hamlet <- "To be, or not to be: that is the question:
Whether 'tis nobler in the mind to suffer
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles,
And by opposing end them?"

hamlet <- str_replace_all(hamlet, "[:punct:]", "")
hamlet <- tolower(unlist(str_split(hamlet, "[:space:]")))

sum(!is.na(str_match(hamlet, "to"))) # Количество слов "to"
sum(!is.na(str_match(hamlet, "b")))
str_length(hamlet)
```

## Факторы

Факторы --- для качественных переменных

### Задача

Используйте показанную мной связку из двух функций, чтобы превратить количественную переменную mag (сила землетрясения в баллах по шкале Рихтера) дата фрейма quakes в качественную. Интервалы должны быть длиной в полбалла, начиная с минимального, при этом левый конец интервала включается. Теперь отсортируйте общее количество случаев, попавших в каждую категорию, в порядке убывания.

```{r}
cut(rnorm(10), -5:5)
table(cut(rnorm(1000), -5:5))

v <- seq(4, 6.5, 0.5)
min(quakes$mag)

table(cut(quakes$mag, v, include.lowest = T, right = F))

```

### Часть 2

```{r}
avian$site_name <- factor(str_replace(avian$Site, "[:digit:]+", ""))
tapply(avian$DBHt, avian$site_name, mean)
```


### Задача

Теперь, когда у нас есть переменная site_name, мы можем оценить общее покрытие в каждой из исследованных местностей. Используйте комбинацию site_name и total_coverage, чтобы определить тот регион, в котором среднее общее покрытие, скажем, наименьшее.

```{r}
tapply(avian$total_coverage, avian$site_name, min)
```

### Задача

Наши любимые учёные, конечно же, соревнуются между собой. Самоё почётное, как нам уже известно, -- найти самый высокий экземпляр вида. В конце сезона исследователи подводят итоги и определяют самого удачливого, который торжественно объявляется чемпионом. После чего все пьют горячий грог и травят байки у костра.
Хорошо у них там!
Давайте поможем нашим друзьям определить, кто из них нашёл самые большие экземпляры по каждому виду.

```{r}
avian %>%
  group_by(Observer) %>%
    summarise(A = max(AHt),
            DB = max(DBHt),
            L = max(LHt),
            E = max(EHt),
            H = max(HHt),
            W = max(WHt))
```

# Модуль 3 --- продвинутое программирование

## Функции

```{r}
x <- 3
y <- 10
z <- 1

seq(from = x, to = y, by = z)

# Эквивалентные записи. Но это треш
seq(by = z, x, y)
seq(x, y, z)
seq(y, z, fr = x)
seq(to = y, by = z, from = x)
seq(b = z, f = x, t = y)

norm
```

Операторт `x %in% y` есть ли вхождение элементов `x` и `y`

```{r}
1:5 %in% c(1, 2, 5)
```

## Function factory

Для того чтобы разобраться как работает фабрика функций, посмотрим пример

```{r}
# Генерируем колоду карт
values <- c("Туз", 2:10, "Валет", "Дама", "Король")
suits <- c("Черви", "Буби", "Крести", "Пики")
card_deck <- outer(values, suits, paste)
length(card_deck)
typeof(card_deck)
str(card_deck)
```

Определим генератор

```{r}
generator <- function(set) function(n) sample(set, n, replace = TRUE)
```

```{r}
card_generator <- generator(card_deck)
card_generator(1)
```



### Задача

Пусть функция `decorate_string` действует поверх функции `paste`, дополнительно приклеивая к результату аргумент `pattern`. При этом этот аргумент должен быть присоединён как в начале строки (строк), так и в конце, но перевёрнутый задом наперёд.

Тут проще всего показать на примерах:

`decorate_string(pattern = "123", "abc")            # "123abc321"`

`decorate_string(pattern = "123", "abc", "def")     # "123abc def321"`

`decorate_string(pattern = "123", c("abc", "def"))  # "123abc321" "123def321" (вектор длины 2)`

Обратите внимание, что функция `decorate_string` должна помнить про аргументы для paste и правильно на них реагировать:

`decorate_string(pattern = "123", "abc", "def", sep = "+")    # "123abc+def321"`

`decorate_string(pattern = "!", c("x", "x"), collapse = "_")  # "!x_x!"`

`decorate_string(pattern = ".:", 1:2, 3:4, 5:6, sep = "&")    # ".:1&3&5:." ".:2&4&6:." (вектор длины 2)`


```{r}
# Долго бился над задачей, потому что не было понимания проброса через многоточие
v <- "123"
u <- "5678"
paste(v, c("o", "x"), sep = "-")

paste(".:", 1:2, 3:4, 5:6, sep = "&")
paste("!", c("x", "x"), collapse = "_")

# Но всё заработало, когда понял и применил

paste(v, paste("abc"), stringi::stri_reverse(v), sep = "")
paste(v, paste("abc", "def"), stringi::stri_reverse(v), sep = "")
paste(v, paste(c("abc", "def")), stringi::stri_reverse(v), sep = "")
paste(v, paste("abc", "def", sep = "+"), stringi::stri_reverse(v), sep = "")

decorate_string <- function(pattern, ...) {
  paste0(pattern, paste(...), stringi::stri_reverse(pattern))
}

decorate_string(pattern = "!", c("x", "x"), collapse = "_")
```

### Задача

Давайте напишем бинарный оператор! Пусть %+% действует на два числовых вектора, складывая их поэлементно, но без учёта правил переписывания: если длина векторов различна, то возвращаем вектор большей длины, но с пропущенными значениями в конце.

Например, 

`1:5 %+% 1:2   # c(2, 4, NA, NA, NA)`
`5 %+% c(2, 6) # c(7, NA)`


Я решил пойти по пути проверки всех длин слагаемых

```{r}
"%+%" <- function(x, y) {
  if (length(x) ==  length(y)) {
    x + y
  } else {
  if (length(x) == 1){
   c(y[length(x)] + x, y[(length(x) + 1):length(y)] * NA) 
  } else {
  if (length(y) == 1){
   c(x[length(y)] + y, x[(length(y) + 1):length(x)] * NA) 
  } else {
  if(length(x)>length(y)){
   c(x[y] + y, x[(length(y) + 1):length(x)] * NA)
  } else {
   c(y[x] + x, y[(length(x) + 1):length(y)] * NA) 
  }  
  }
  }
  }
}

5 %+% c(2, 6) # c(7, NA)
1:5 %+% 1:2   # c(2, 4, NA, NA, NA)
1:2 %+% 1:5 # 2 4 NA NA NA
1 %+% 1
1:2 %+% 1:2
```

Но оказывается можно сделать всё гораздо проще, через анонимную функцию

```{r}
"%+%" <- function(x, y) {
  sapply(1:max(length(x),length(y)),function(i) x[i]+y[i])
}
# красота
```

### Задача

Воспользуйтесь подготовленным мной шаблоном, чтобы получить две функции, содержащие честную и нечестную рулетку. Честная -- это когда все имеющиеся значения (всего их 37) выпадают с равной вероятностью. А нечестная пусть выдаёт все значения, кроме зеро, с равной вероятностью. Что же касается зеро (первый элемент определённого мной вектора `roulette_values)`, то вероятность его выпадения пусть будет в два раза больше, чем любого другого значения. Не переборщите, иначе игроки заподозрят неладное!

Как и в предыдущем видео, функция `generator` -- фабрика функций, но с ещё более широкими возможностями. Обратите внимание, как я объявил аргумент `prob` по умолчанию. Я ожидаю, что в этом случае вызов `generator(roulette_values)` без аргумента prob даст функцию для вызова честной рулетки `fair_roulette`. Для нечестной рулетки `rigged_roulette` вызов уточните самостоятельно. Я буду проверять рулетки вызовом обеих функций, так что, пожалуйста, убедитесь, что это функции, для которых обращение вида `fair_roulette(n)` и  `rigged_roulette(n)` приведёт к получению `n` независимых бросков.

Вероятность выпадения одного из 37 чисел равна $\frac{1}{37}$. Чтобы зеро выпадало в два раза больше его вероятность должна быть в два раза выше, т.е. $\frac{2}{37}$
```{r}
# Задаём сектора рулетки
roulette_values <- c("Zero!", 1:36)

# Смотрим какова вероятность выпадения каждого числа
rep(1/length(roulette_values), length(roulette_values))

# пишем фабрику функций
generator <- function(set, prob = rep(1/length(set), length(set))) {
  function(n) sample(set, n, prob = prob, replace = TRUE)
}

# Генерируем честную и бесчестную рулетку
fair_roulette <- generator(roulette_values)
rigged_roulette <- generator(roulette_values, prob = c(2, rep(1, length(set) - 1)) / length(set))

```

### Задача

Возьмите исходный avianHabitat. Примените к нему процедуру объединения по географической локации (Site). Мы будем работать со всеми имеющимися видами одновременно. Интересующая нас характеристика --- высота растений (*Ht). 

Теперь произведите следующий подсчёт по всем комбинациям места (Site) и наблюдателя (Observer). Интересующая нас статистика -- количество тех замеров, где обнаруживается хотя бы один экземпляр вида. Соберите эту статистику по всем видам. У вас получится таблица, в которой тройке вида (место M, наблюдатель N, вид P) соответствует число замеров в M, произведенных N, где обнаружен хотя бы один P.

```{r}
avian <- read_csv("https://raw.githubusercontent.com/tonytonov/Rcourse/master/R%20programming/avianHabitat.csv")
```


```{r}
avian %>% 
  select(Site, Observer, contains("Ht")) %>% 
  gather(3:8, key = "plant", value = "high") %>% 
  mutate(Site = factor(str_replace(Site, "[:digit:]+", "")),
         plant = factor(str_replace(plant, "Ht", ""))) %>%
  filter(high > 0) %>% 
  group_by(Site, Observer, plant) %>% 
  tally() %>%  # эта функция считает количество входов
  View()
```

## Объектно ориентированные системы

* S3-классы --- функции могут иметь разное поведение в зависимости от класса

```{r}
x <- paste(letters, "apply", sep = "")
vef = Vectorize(existsFunction, "f")
y <- x[vef(x)]
```

### Задача

Составьте вектор cat_catalogue, содержащий всевозможные комбинации имеющихся характеристик, и отсортируйте его. Помимо научной ценности, каталог (котолог?) можно использовать как средство для выбора домашнего питомца. Допустим, я хочу завести кота. Тогда я беру случайное число, скажем, 42, и выбираю запись под этим номером. Что за кот мне достался?

```{r}
cat_temper <- c("задиристый", "игривый", "спокойный", "ленивый")
cat_color <- c("белый", "серый", "чёрный", "рыжий")
cat_age <- c("кот", "котёнок")
cat_trait <- c("с умными глазами", "с острыми когтями", "с длинными усами")

Vectorize(outer)

v1 <- as.vector(outer(cat_temper, cat_color, paste))
v2 <- as.vector(outer(cat_age, cat_trait, paste))

v3 <- as.vector(outer(v1, v2, paste)) 

v3[order(v3)][42]
```

### Задача

Такие функции, как print, summary и plot, удобно определены как generic функции. Более того, если у вас есть собственные классы, то вы можете задавать свои варианты поведения для этих функций при передаче объектов вашего класса. Подробнее об этом можно прочитать в справке ?Methods, и Advanced R.

Найдите, какие функции вида fun.obj существуют для этих трёх функций в базовом R.

```{r}
funs <- c("print","summary","plot")
meths <- lapply(funs, methods)

grepl("matrix", meths)
grepl("function", meths)
grepl("default", meths)
```


### Задача

Расположите сниппеты по быстродействию

```{r}
m1 <- function(x, y) {
  m <- matrix(0, length(x), length(y))
  for (i in 1:length(x)) 
    for (j in 1:length(y)) {
      m[i, j] = x[i] * y[j]
    }
  m
}

m2 <- function(x, y) {
  vapply(y, function(i) i * x, numeric(length(x)))
}

m3 <- function(x, y) x %o% y

x <- rnorm(100)
y <- runif(1000)
all.equal(m1(x, y), m2(x, y))
all.equal(m2(x, y), m3(x, y))

library(microbenchmark)
microbenchmark(m1(x, y), m2(x, y), m3(x, y))
```

### Задача 

При помощи функции simulate_walk из предыдущего видео можно моделировать случайное блуждание на отрезке [lower, upper]. Это достаточно простой случай. Больший интерес представляют задачи с блужданием по плоскости, то есть в размерности 2.

Возьмите написанную мной функцию и измените её так, чтобы блуждание начиналось в центре координат (0, 0), а все переходы по координатам x и y были бы независимы и имели стандартное нормальное распределение. Если вас пугают эти слова, то это то же самое, что делал я, только отдельно по x и по y.

Процесс обрывается в момент выхода за границу круга с центром в (0, 0) и радиусом 6. Вероятность поглощения на каждом шаге равна 0.01. Максимальное количество шагов — 100. Расстояние, разумеется, евклидово: расстояние от точки (x, y) до (0, 0) есть
. Один шаг процесса подразумевает изменение обеих координат одновременно!

Теперь, когда все параметры зафиксированы, вероятность выхода частицы за пределы круга строго определена. Наша задача — найти эту вероятность. Это некоторое число, не зависящее от реализации алгоритма. Его можно даже вычислить теоретически, но это не так-то просто. Поэтому в подобных случаях пользуются моделированием: запускают алгоритм достаточно большое количество раз (скажем, миллион траекторий) и оценивают долю частиц, вылетевших за границу. Эта доля и есть приближение вероятности, которую мы ищем (реверанс в сторону закона больших чисел).

Для того, чтобы в нашей задаче определить нужную вероятность с точностью до целых процентов, достаточно будет ста тысяч запусков, у меня это несколько секунд. Если у вас считается слишком долго, то грубую оценку можно получить и для десяти тысяч запусков.

В ответе укажите вероятность вылета частицы в процентах, с точностью до целых процентов, в виде XX (например, 14, без указания значка процентов). Вероятность должна получиться больше 50%.

```{r}
simulate_walk <- function(lower = -10, upper = 10, n_max = 200, p = 1e-3) {
  current_position <- (lower + upper) / 2
  for (i in 1:n_max) {
    is_absorbed <- rbinom(1, 1, p)
    if (is_absorbed) return(list(status = "Absorbed", 
                                 position = current_position, 
                                 steps = i))
    current_position <- current_position + rnorm(1)
    if (current_position < lower) return(list(status = "Left breach", 
                                              position = current_position, 
                                              steps = i))
    if (current_position > upper) return(list(status = "Right breach", 
                                              position = current_position, 
                                              steps = i))
  }
  return(list(status = "Max steps reached", 
              position = current_position,
              steps = n_max))
}

# Simulate results
result <- replicate(1000, simulate_walk(), simplify = FALSE)
result <- data.frame(
  status = sapply(result, function(x) x$status),
  position = sapply(result, function(x) x$position),
  steps = sapply(result, function(x) x$steps)
)

# Inspect results
tapply(result$position, result$status, length)
tapply(result$steps, result$status, mean)
```