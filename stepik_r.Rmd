---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Модуль 1

```{r}
library(tidyverse)
library(randtoolbox)
```

## 1.3 Векторы (часть 1)

Перед тем как создавать функцию, пробуем сделать в рабочем окружении. 

Сначала я попробовал функцию `rev()`, но она сортирует в пределах одного вектора:

```{r}
m <- 3
n <- 7
f1 <- seq(0, 1, by = 1/m)
f2 <- seq(0, 1, by = 1/n)
w <- c(f1, f2)
r <- rev(w)
unique(r)
```

Поэтому лучше использовать функцию `sort()`, она сортирует более привычным способом 

```{r}
m <- 3
n <- 7
f1 <- seq(0, 1, by = 1/m)
f2 <- seq(0, 1, by = 1/n)
w <- c(f1, f2)
r <- sort(w)
unique(r)
```

Теперь всё работает. Можно переходить к намписанию функции

```{r}
get_fractions <- function(m, n) {
x <- seq(0, 1, by = 1/m)
y <- seq(0, 1, by = 1/n)
return(unique(sort(c(x, y), decreasing = TRUE)))
}
get_fractions(3, 7)
```

## 1.4 Управляющие конструкции, работа с пакетами

### Циклы `if`, `else`, `ifelse`

Переносить `else` на другую строку от курвы нельзя.

Если число больше 1.5 напечатай Yammi, иначе напечатай Less

```{r}
if (sqrt(2) > 1.5) {
  print("Yammi")
} else {
  print("Less")
}
```

Если число больше 0.5 выведи Орёл, иначе Решка
```{r}
runif(8)      # Рандомное число от 0 до 1
ifelse(runif(8) > 0.5, "Орёл", "Решка")
```

### Циклы `repeat`

для каждого числа повтори прибавление к этому числу рандомного (от 0 до 1) и выведи на печать, если число больше пяти остановись

```{r}
i <- 0
repeat {
  i <- i + runif(1)
  print(i)
  if (i > 5) break
}
```

### Циклы `while`

Пока число больше 1000 раздели это число пополам и выведи на печать
```{r}
i <- 2^14
while (i > 1000) {
  i <- i/2
  print(i)
}
```

### Циклы `for`

Для каждого `i` в диапазоне от 1 до 8, если остаток от деления числа равен нулю выведи число на печать
```{r}
for (i in 1:8) {
  if (i %% 2 == 0) print(i)
}
```

### Задача 1

Если утверждение верное, поставьте галочку. Впрочем, это лишняя информация, смысл задания и так понятен.


F Синтаксис цикла for зависит от типа вектора в условии.
T ifelse -- это векторизованный вариант if.
F В цикле if можно переносить условие else на новую строку.
T Не стоит использовать цикл for, если есть возможность использовать векторизацию.
F %% -- это оператор целочисленного деления (integer division).

### Задача 2

```{r}
set.seed(1337)
x <- runif(1e6, min = -1, max = 1)
```

Теперь в вашем распоряжении вектор x длиной один миллион. Мне крайне интересно, сколько среди них чисел в диапазоне (-0.2, 0.3). Для определённости не включая границы интервала. Впрочем, кто знаком с теорией вероятностей, тот знает, что это уточнение несущественно.

```{r}
sum(between(x, -0.2, 0.3))
```

### Задача 3

Вам не нравятся ни монетка, ни "камни-ножницы-бумага"? Хорошо, давайте играть в "Монополию", только у меня нет кубика. Напишите его сами!

Функция `dice_roll(n)` должна выдавать n независимых бросков игрального кубика. Допустимые значения, разумеется, в диапазоне от 1 до 6.

Только учтите, что если кубик нечестный (не все грани выпадают с равной вероятностью), я это проверю и играть с вами не сяду!


Для генерации бросков будем использовать функцию `sample()`. Хэлп по ней всё расставит на свои места


```{r}
dice_roll <- function(n) {
x <- sample(1:6, n, replace = TRUE)
  return(x)
}

ggplot() + aes(dice_roll(1000))+ geom_histogram(binwidth=1, colour="black", fill="white")
sessionInfo()
```

## 1.5 Векторы (Часть 2)

```{r}
x <- seq(10, 100, 10)

x[c(1, 2, 4)]

x[rep(c(T,F), 5)]
```

```{r}

```

Функция `all` и `any`

```{r}
all(x < 200); all(x > 200)
```

Функция `which` --- если нас интересует позиции

```{r}
which(x <= 100)
```


### Задача 1

Пусть имеется вектор `x` произвольного типа. Какая конструкция может быть использована, чтобы получить содержимое вектора x без каждого седьмого элемента?
P.S. Давайте предполагать, что понятие "каждый седьмой" имеет смысл, то есть элементов в векторе хотя бы семь.

```{r}
x <- seq(1, 10, 1)
```

```{r}
x[c(rep(T, 6), F)]
x[-(seq(7, length(x), by = 7))]
x[-(seq(7, length(x), by = 7))]
x[1:length(x) %% 7 > 0]
x[-(1:floor(length(x)/7) * 7)]
x[1:length(x) %% 7 != 0]
```


```{r}
max(c(TRUE, FALSE))
which(c("A", "BBB", "Z"))
22:19
c("A", "BBB", "Z")
c("1", "99", "HI")
c(TRUE, FALSE)

x <- c(1:4, 11)
which.max(x)

x <- rep(1, 10); length(max(x)); length(which.max(x)); length(x == 1)

max(c("A", "BBB", "Z"))
max(c("1", "99", "HI"))
which.max(c("1", "100", "99"))
```

### Задача 2

```{r}
x <- c(1, 23, 5, 19, 15, 13, 5)
letters[x]
```

### Задача 3

Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает `TRUE`, если вектор обладает свойством нестрогой монотонности, то есть является либо несторого возрастающим, либо нестрого убывающим. В противном случае функция возвращает `FALSE`.

```{r}
is_monotone <- function(x){
  if (all(x[-1] - x[-length(x)] >= 0)) {
    return(TRUE)
  } else {
  if (all(x[-1] - x[-length(x)] <= 0)) {
    return(TRUE)
  }  else {
    return(FALSE)
  }
  }
}

x <- c(0, 0, 3, 4, 4, 8)
y <- rep(0, 10)
z <- c(10:1)
n <- c(0, 0, 3, 2, 4, 8)

is_monotone(x)
is_monotone(z)
is_monotone(y)
is_monotone(n)
```


### Задача 4

Пусть у нас есть `n` предметов, из которых нужно выбрать `k` штук.

Известнейшая комбинаторная формула $$C_{n}^k = \frac{n!}{k!(n−k)!}$$ ("Цэ из эн по ка") задаёт количество всевозможных сочетаний. Похожий вид имеет и количество сочетаний с повторениями (мультикомбинаций).

Запрограммируйте оба этих значения в виде функции, зависящей от `n` и `k`. Аргумент `with_repetitions` будет отвечать за вариант подсчёта: если он `FALSE`, то пусть считается количество сочетаний, а если `TRUE`, то сочетаний с повторениями.

```{r}
combin_count <- function(n, k, with_repretitions = FALSE) {
if(with_repretitions == FALSE) {
  return(factorial(n) / (factorial(k) * factorial(n-k)))
} else {
  return(factorial(n+k-1) / (factorial(k) * factorial(n-1)))
}
}

n <- 5
k <- 3
factorial(20)

combin_count(5, 3)
factorial(5) # 120
factorial(3) # 6
factorial(2) # 2

```


