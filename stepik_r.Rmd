---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Модуль 1 --- базовые структуры и понятия

```{r}
library(tidyverse)
library(randtoolbox)
```

## 1.3 Векторы (часть 1)

Перед тем как создавать функцию, пробуем сделать в рабочем окружении. 

Сначала я попробовал функцию `rev()`, но она сортирует в пределах одного вектора:

```{r}
m <- 3
n <- 7
f1 <- seq(0, 1, by = 1/m)
f2 <- seq(0, 1, by = 1/n)
w <- c(f1, f2)
r <- rev(w)
unique(r)
```

Поэтому лучше использовать функцию `sort()`, она сортирует более привычным способом 

```{r}
m <- 3
n <- 7
f1 <- seq(0, 1, by = 1/m)
f2 <- seq(0, 1, by = 1/n)
w <- c(f1, f2)
r <- sort(w)
unique(r)
```

Теперь всё работает. Можно переходить к намписанию функции

```{r}
get_fractions <- function(m, n) {
x <- seq(0, 1, by = 1/m)
y <- seq(0, 1, by = 1/n)
return(unique(sort(c(x, y), decreasing = TRUE)))
}
get_fractions(3, 7)
```

## 1.4 Управляющие конструкции, работа с пакетами

### Циклы `if`, `else`, `ifelse`

Переносить `else` на другую строку от курвы нельзя.

Если число больше 1.5 напечатай Yammi, иначе напечатай Less

```{r}
if (sqrt(2) > 1.5) {
  print("Yammi")
} else {
  print("Less")
}
```

Если число больше 0.5 выведи Орёл, иначе Решка
```{r}
runif(8)      # Рандомное число от 0 до 1
ifelse(runif(8) > 0.5, "Орёл", "Решка")
```

### Циклы `repeat`

для каждого числа повтори прибавление к этому числу рандомного (от 0 до 1) и выведи на печать, если число больше пяти остановись

```{r}
i <- 0
repeat {
  i <- i + runif(1)
  print(i)
  if (i > 5) break
}
```

### Циклы `while`

Пока число больше 1000 раздели это число пополам и выведи на печать
```{r}
i <- 2^14
while (i > 1000) {
  i <- i/2
  print(i)
}
```

### Циклы `for`

Для каждого `i` в диапазоне от 1 до 8, если остаток от деления числа равен нулю выведи число на печать
```{r}
for (i in 1:8) {
  if (i %% 2 == 0) print(i)
}
```

### Задача 1

Если утверждение верное, поставьте галочку. Впрочем, это лишняя информация, смысл задания и так понятен.


F Синтаксис цикла for зависит от типа вектора в условии.
T ifelse -- это векторизованный вариант if.
F В цикле if можно переносить условие else на новую строку.
T Не стоит использовать цикл for, если есть возможность использовать векторизацию.
F %% -- это оператор целочисленного деления (integer division).

### Задача 2

```{r}
set.seed(1337)
x <- runif(1e6, min = -1, max = 1)
```

Теперь в вашем распоряжении вектор x длиной один миллион. Мне крайне интересно, сколько среди них чисел в диапазоне (-0.2, 0.3). Для определённости не включая границы интервала. Впрочем, кто знаком с теорией вероятностей, тот знает, что это уточнение несущественно.

```{r}
sum(between(x, -0.2, 0.3))
```

### Задача 3

Вам не нравятся ни монетка, ни "камни-ножницы-бумага"? Хорошо, давайте играть в "Монополию", только у меня нет кубика. Напишите его сами!

Функция `dice_roll(n)` должна выдавать n независимых бросков игрального кубика. Допустимые значения, разумеется, в диапазоне от 1 до 6.

Только учтите, что если кубик нечестный (не все грани выпадают с равной вероятностью), я это проверю и играть с вами не сяду!


Для генерации бросков будем использовать функцию `sample()`. Хэлп по ней всё расставит на свои места


```{r}
dice_roll <- function(n) {
x <- sample(1:6, n, replace = TRUE)
  return(x)
}

ggplot() + aes(dice_roll(1000))+ geom_histogram(binwidth=1, colour="black", fill="white")
sessionInfo()
```

## 1.5 Векторы (Часть 2)

```{r}
x <- seq(10, 100, 10)

x[c(1, 2, 4)]

x[rep(c(T,F), 5)]
```

```{r}

```

Функция `all` и `any`

```{r}
all(x < 200); all(x > 200)
```

Функция `which` --- если нас интересует позиции

```{r}
which(x <= 100)
```


### Задача 1

Пусть имеется вектор `x` произвольного типа. Какая конструкция может быть использована, чтобы получить содержимое вектора x без каждого седьмого элемента?
P.S. Давайте предполагать, что понятие "каждый седьмой" имеет смысл, то есть элементов в векторе хотя бы семь.

```{r}
x <- seq(1, 10, 1)
```

```{r}
x[c(rep(T, 6), F)]
x[-(seq(7, length(x), by = 7))]
x[-(seq(7, length(x), by = 7))]
x[1:length(x) %% 7 > 0]
x[-(1:floor(length(x)/7) * 7)]
x[1:length(x) %% 7 != 0]
```


```{r}
max(c(TRUE, FALSE))
which(c("A", "BBB", "Z"))
22:19
c("A", "BBB", "Z")
c("1", "99", "HI")
c(TRUE, FALSE)

x <- c(1:4, 11)
which.max(x)

x <- rep(1, 10); length(max(x)); length(which.max(x)); length(x == 1)

max(c("A", "BBB", "Z"))
max(c("1", "99", "HI"))
which.max(c("1", "100", "99"))
```

### Задача 2

```{r}
x <- c(1, 23, 5, 19, 15, 13, 5)
letters[x]
```

### Задача 3

Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает `TRUE`, если вектор обладает свойством нестрогой монотонности, то есть является либо несторого возрастающим, либо нестрого убывающим. В противном случае функция возвращает `FALSE`.

```{r}
is_monotone <- function(x){
  if (all(x[-1] - x[-length(x)] >= 0)) {
    return(TRUE)
  } else {
  if (all(x[-1] - x[-length(x)] <= 0)) {
    return(TRUE)
  }  else {
    return(FALSE)
  }
  }
}

x <- c(0, 0, 3, 4, 4, 8)
y <- rep(0, 10)
z <- c(10:1)
n <- c(0, 0, 3, 2, 4, 8)

is_monotone(x)
is_monotone(z)
is_monotone(y)
is_monotone(n)
```


### Задача 4

Пусть у нас есть `n` предметов, из которых нужно выбрать `k` штук.

Известнейшая комбинаторная формула $$C_{n}^k = \frac{n!}{k!(n−k)!}$$ ("Цэ из эн по ка") задаёт количество всевозможных сочетаний. Похожий вид имеет и количество сочетаний с повторениями (мультикомбинаций).

Запрограммируйте оба этих значения в виде функции, зависящей от `n` и `k`. Аргумент `with_repetitions` будет отвечать за вариант подсчёта: если он `FALSE`, то пусть считается количество сочетаний, а если `TRUE`, то сочетаний с повторениями.

```{r}
combin_count <- function(n, k, with_repretitions = FALSE) {
if(with_repretitions == FALSE) {
  return(factorial(n) / (factorial(k) * factorial(n-k)))
} else {
  return(factorial(n+k-1) / (factorial(k) * factorial(n-1)))
}
}

n <- 5
k <- 3
factorial(20)

combin_count(5, 3)
factorial(5) # 120
factorial(3) # 6
factorial(2) # 2

```

# Модуль 2 --- продвинутые структуры

## Матрицы и списки ч1

Матрица --- двумерный массив данных одного типа

```{r}
matrix(1:6, nrow = 2, ncol = 3)
```

```{r}
matrix(1:6, nrow = 2)
```

```{r}
matrix(1:6, nrow = 2, byrow = T)
```

Чтобы прочекать размерность, можно использовать функцию `dim` 

```{r}
m <- matrix(1:6, ncol = 3)
dim(m)
```

Арифметические операции --- действуют поэлментно

```{r}
m1 <- matrix(1:4, nrow = 2)
m2 <- matrix(c(1, 2, 2, 3), nrow = 2)

m1 + m2

m1 + 5
```

Умножение по правилам линейной алгебры

```{r}
m1 %*% m2
```

Вот немного [материала по этой теме](http://mathhelpplanet.com/static.php?p=umnozhenie-matrits)

И ещё  [схема умножения](img\matrix.png)

Индексирование --- так же как для векторово

```{r}
m <- matrix(1:10, ncol = 5)
m[1,3]
```


Обнулить всю первую строчку

```{r}
m[1, ] <- 0; m
```

Переприсвоить все столбцы кроме пятого

```{r}
m[, -5] <- 11:18; m
```

Схлопывание размерности. Даём в индексах вектор --- получаем в ответ матрицу

```{r}
m <- matrix(1:10, ncol = 5)
ind <- c(1, 3, 5)
m[, ind]
```

Даём в индексе число --- получаем в ответ вектор
```{r}
ind <- 3
m[, ind]
```

Схлопыванием размерности можно управлять параметром `drop`. Установив `FALSE` на выдаче получим матрицу

```{r}
m[, ind, drop = F]
```

Именование матриц можно делать при помощи функций 
`rownames()` и `colnames()`.

```{r}
m <- matrix(1:10, ncol = 5)
rownames(m) <- c("row1", "row2")
colnames(m) <- paste0("column", 1:5)
# Теперь можно обращаться по именам столбцов
```

`paste0` --- склеивает аргументы в вектор строк. 

Применение функций к матрице. `apply()`

```{r}
m <- matrix(1:25, 5)
f <- function(x) sum(x^2)
```

Функция `apply()` проходит по столбцам или строкам.

```{r}
apply(m, 2, f)
```

Можно применять и ко всей матрице, если вторым аргументом подавать вектор.

```{r}
apply(m, 1:2, function(i) if (i>13) i else 13)
```

Но тоже самое можно сделать при помощи __анонимной функции__. Она не имеет имени. Для этого воспользуемся матричным индексированием

```{r}
m[m <= 13] <- 13; m
```

Те элементы матрицы которые меньше тринадцати --- замени на 13

### Задача 1

```{r}
m <- 5
n <- 2
mat <- matrix(1:10, m, n)
mat[m, n] # Вектор длины 1, содержащий элемент в правом нижнем углу
# mat[n, m] # ошибочная запись: ошибки не будет только при m=n
mat[m, ] # Вектор, содержащий строку номер m
mat[m, , drop = FALSE] # Вектор, содержащий строку (ряд) номер m
mat[, n, drop = F] # Матрица, состоящая из одного столбца (колонки) номер n
mat[, n, drop = TRUE] # Вектор, содержащий столбец (колонку) номер n
mat > 5 # Вектор, содержащий столбец (колонку) номер n
mat[mat > 5] # Вектор, содержащий все значения по условию (возможно, пустой)
```

### Задача 2

Предположим, что у нас есть целочисленный вектор `v` и число `n`. Наша задача — найти позицию элемента в векторе, который ближе всего к числу `n`. При этом если таких элементов несколько, необходимо указать все позиции.

Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. Индексы должны быть выстроены по возрастанию.

Пример. Пусть `v <- c(5, 2, 7, 7, 7, 2, 0, 0)` и `n=1`. Ответом будет вектор

```{r}
n <- 5
v <- c(5, 2, 7, 7, 7, 2, 0, 0)

Mod(v - n)

Mod(min(v - n))

which(Mod(v - n) == n)

min(Mod(v - n))

which(Mod(v - n) == min(Mod(v - n)))

```


```{r}
find_closest <- function(v, n) {
which(Mod(v - n) == min(Mod(v - n)))
}
```

## Матрицы и списки ч2

Предположим нам необходимо соединить две матрица диагональным способом. То есть нам необходимо получить матрицу `m3` в которой левый верхний угол это матрица `m1`, а правый нижний угол это матрица `m2`, а остальные элементы заполнены какими-то значениями `fill`.

```{r}
bian_diag <- function(m1, m2, fill) {
  m3 <- matrix(fill, 
               nrow = nrow(m1) + nrow(m2),
               ncol = ncol(m1) + ncol(m2))
  m3[1:nrow(m1), 1:ncol(m1)] <- m1
  m3[nrow(m1) + 1:nrow(m2), ncol(m1) + 1:ncol(m2)] <- m2
  m3
}
```

```{r}
m1 <- matrix(1:12, nrow = 3)
m2 <- matrix(10:15, nrow = 3)
bian_diag(m1, m2, fill = 0)
```

### Задача 3

Напишите функцию, которая принимает одно целое число `n`, а возвращает “ступенчатую” матрицу, состоящую из `n` этажей. Этажи нумеруются с первого, ширина каждой ступеньки равна одной строке или столбцу.

Пример. Пусть `n=4`, тогда необходимо вернуть матрицу вида

  1   1   1   1   1   1   1
  1   2   2   2   2   2   1
  1   2   3   3   3   2   1
  1   2   3   4   3   2   1
  1   2   3   3   3   2   1
  1   2   2   2   2   2   1
  1   1   1   1   1   1   1

```{r}
v <- c(1:4)

n <- matrix(v, length(v), length(v), byrow = T)

n[c(1:3, 1 , 3:1),c(1:3, 1, 3:1)]

n[c(1:4, 3:1),c(1:4, 3:1)] + t(n[c(1:4, 3:1),c(1:4, 3:1)])

m <- n[c(1:4, 3:1),c(1:4, 3:1)]
m[c(1, 7), ] <- 1; m


t(m)
lower.tri(m)
solve(m)
```

