---
title: "data_analysis"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Этап 2

## Используемые библиотеки

```{r}
library(tidyverse)
```

## Функции семейства apply

### Основы

Возьмём встроенный набор данных

```{r}
data(diamonds)
str(diamonds)
```

Посмотрим минимальный размерность для каждого бриллианта

Через цикл:

```{r}
min_size <- c()

for (i in 1:nrow(diamonds)) {
  min_size <- c(min_size, min(diamonds[i, 8:10]))
}

head(min_size)
```

Это очень долго, в силу особенностей языка R. Можно ускорить, если сообщить какой тип данных будет у вектора, и сколько там будет значений. На каждом этапе сейчас мы перезаписываем.

```{r}
min_size <- c(nrow(diamonds))

for (i in 1:nrow(diamonds)) {
  min_size[i] <- min(diamonds[i, 8:10])
}
```

Теперь разберём правильный код. На всём протяжении работы с данными, мы будем применять к данным какие-то функции. Поэтому apply становится незаменимым фреймворком

```{r}
min_size <- apply(diamonds[, 8:10], 1, min) # 1 -- работая со строчками
```

Задача решена в одну строчку и очень быстро.

### Как работает

```{r}
apply(X, margin, ...)
```

X --- данные

MARGIN --- как рименяем функцию, по строчкам или по столбцам

FUN --- какая функция применяется

Потренируемся.

```{r}
d <- matrix(rnorm(30), nrow = 5)

apply(d, 1, sd)
```

apply взяла первую строчку данных, применила к ним sd. Потом вторую, и т.д. до конца.


```{r}
apply(d, 2, sd)
```

Всё тоже самое --- только к колнкам

### Задача

В переменной d сохранен dataframe с произвольным числом количественных переменных. При помощи функции apply найдите максимальное значение в каждой строке. Сохраните результат (вектор максимальных значений) в переменную row_max.

```{r}
row_max <- apply(d, 1, max)
```

### Как работает, продолжение

Если функция возвращает одно значение по результатам работы, то мы получаем вектор длинной по кол-ву строк или столбцов. Но что если функция возврщает несколько значений. Допустим функция range --- максимум и минимум

```{r}
my_range <- apply(d, 2, range)
```

Мы получаем не вектор, а матрицу.

А что если функция возвращает разное кол-во данных. Например Функция которая выводит только выбросы

```{r}
outliers_count <- function(x){
  outliers <- x[abs(x - mean(x)) > 2 * sd(x)]
  if (length(outliers) > 0) {
    return(outliers)
  } else {
    return("There are no outliers")
  }
}
```

Посмотрим есть ли выбросы в данных iris

```{r}
iris_num <-  iris[, 1:4]

apply(iris_num, 2, outliers_count)
```

Так как длины разные, то выходная запись --- лист с данными.

Apply --- инструмент, который хорошо заменяет цикл for.

### Многоточие

Через многоточие можно передавать аргументы используемой функции

```{r}
head(airquality)

apply(airquality, 2, mean)
```

Работает вот так

```{r}
apply(airquality, 2, mean, na.rm = T)
```

### Компактная функция --- можно прописывать функцию в теле apply

```{r}
set.seed(42)

d <- as.data.frame(matrix(rnorm(30), nrow = 5))

my_fun <- function(x) x * 2

```

Такая функция нигде не засветится.

Внутри функции apply можно записывать функцию. Это короткая функция

```{r}
apply(d, 2, function(x) x[x < 0])
```

### Задача

Давайте завершим и слегка модифицируем задачу из предыдущей лекции. Напишите функцию get_negative_values, которая получает на вход dataframe произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта переменная нас не интересует, для всех переменных, в которых есть отрицательные значения мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой переменной (смотри пример работы функции).

```{r}
test_data <- as.data.frame(list(V1 = c(NA, -0.5, -0.7, -8), V2 = c(-0.3, NA, -2, -1.2), V3 = c(1, 2, 3, NA)))

get_negative_values <- function(test_data){    
negative_col <- apply(test_data, 2, function(x) any(x[!is.na(x)] < 0))    
return(apply(test_data[negative_col], 2, function(x) x[!is.na(x) & x <0]))}
```

