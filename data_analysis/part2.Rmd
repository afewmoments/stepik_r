---
title: "data_analysis"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Этап 2

## Используемые библиотеки

```{r}
library(tidyverse)
```

## Функции семейства apply

### Основы

Возьмём встроенный набор данных

```{r}
data(diamonds)
str(diamonds)
```

Посмотрим минимальный размерность для каждого бриллианта

Через цикл:

```{r}
min_size <- c()

for (i in 1:nrow(diamonds)) {
  min_size <- c(min_size, min(diamonds[i, 8:10]))
}

head(min_size)
```

Это очень долго, в силу особенностей языка R. Можно ускорить, если сообщить какой тип данных будет у вектора, и сколько там будет значений. На каждом этапе сейчас мы перезаписываем.

```{r}
min_size <- c(nrow(diamonds))

for (i in 1:nrow(diamonds)) {
  min_size[i] <- min(diamonds[i, 8:10])
}
```

Теперь разберём правильный код. На всём протяжении работы с данными, мы будем применять к данным какие-то функции. Поэтому apply становится незаменимым фреймворком

```{r}
min_size <- apply(diamonds[, 8:10], 1, min) # 1 -- работая со строчками
```

Задача решена в одну строчку и очень быстро.

### Как работает

```{r}
apply(X, margin, ...)
```

X --- данные

MARGIN --- как рименяем функцию, по строчкам или по столбцам

FUN --- какая функция применяется

Потренируемся.

```{r}
d <- matrix(rnorm(30), nrow = 5)

apply(d, 1, sd)
```

apply взяла первую строчку данных, применила к ним sd. Потом вторую, и т.д. до конца.


```{r}
apply(d, 2, sd)
```

Всё тоже самое --- только к колнкам

#### Задача

В переменной d сохранен dataframe с произвольным числом количественных переменных. При помощи функции apply найдите максимальное значение в каждой строке. Сохраните результат (вектор максимальных значений) в переменную row_max.

```{r}
row_max <- apply(d, 1, max)
```

### Как работает, продолжение

Если функция возвращает одно значение по результатам работы, то мы получаем вектор длинной по кол-ву строк или столбцов. Но что если функция возврщает несколько значений. Допустим функция range --- максимум и минимум

```{r}
my_range <- apply(d, 2, range)
```

Мы получаем не вектор, а матрицу.

А что если функция возвращает разное кол-во данных. Например Функция которая выводит только выбросы

```{r}
outliers_count <- function(x){
  outliers <- x[abs(x - mean(x)) > 2 * sd(x)]
  if (length(outliers) > 0) {
    return(outliers)
  } else {
    return("There are no outliers")
  }
}
```

Посмотрим есть ли выбросы в данных iris

```{r}
iris_num <-  iris[, 1:4]

apply(iris_num, 2, outliers_count)
```

Так как длины разные, то выходная запись --- лист с данными.

Apply --- инструмент, который хорошо заменяет цикл for.

### Многоточие

Через многоточие можно передавать аргументы используемой функции

```{r}
head(airquality)

apply(airquality, 2, mean)
```

Работает вот так

```{r}
apply(airquality, 2, mean, na.rm = T)
```

### Компактная функция --- можно прописывать функцию в теле apply

```{r}
set.seed(42)

d <- as.data.frame(matrix(rnorm(30), nrow = 5))

my_fun <- function(x) x * 2

```

Такая функция нигде не засветится.

Внутри функции apply можно записывать функцию. Это короткая функция

```{r}
apply(d, 2, function(x) x[x < 0])
```

#### Задача

Давайте завершим и слегка модифицируем задачу из предыдущей лекции. Напишите функцию get_negative_values, которая получает на вход dataframe произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта переменная нас не интересует, для всех переменных, в которых есть отрицательные значения мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой переменной (смотри пример работы функции).

```{r}
test_data <- as.data.frame(list(V1 = c(NA, -0.5, -0.7, -8), V2 = c(-0.3, NA, -2, -1.2), V3 = c(1, 2, 3, NA)))

get_negative_values <- function(test_data){    
negative_col <- apply(test_data, 2, function(x) any(x[!is.na(x)] < 0))    
return(apply(test_data[negative_col], 2, function(x) x[!is.na(x) & x <0]))}
```

### Продолжение

Можно было бы применить дисперсионный анализ

```{r}
head(iris)
aov(Sepal.Length ~ Species, data = iris)
```

Но это делается только по одной переменной, давайте сделаем это для всех переменных
Берем только количественные перменные

```{r}
aov_result <- apply(iris[, 1:4], 2, function(x) aov(x ~ iris$Species))

norm_test <- apply(iris[, 1:4], 2, 
                   function(x) shapiro.test(x))


# Сразу достаём p.value
norm_test_p <- apply(iris[, 1:4], 2, 
                   function(x) shapiro.test(x)$p.value)

```

Этот код сделает сравнение трёх групп между собой по всем количественным перменным

Применяем статистический тест к нескольким параметрам

Для второй части по статистике --- p-уровень значимость

#### Задача

Напишите функцию na_rm которая заменяет все пропущенные значения в столбцах dataframe на соответствующее среднее значение. То есть все NA в первом столбце заменяются на среднее значение первого столбца (рассчитанного без учета NA). Все NA второго столбца заменяются на среднее значение второго столбца и т.д.  Замена пропущенных значений на среднее. change NA to mean

Функция na_rm на вход получает dataframe произвольной размерности, состоящий из количественных переменных. Функция должна возвращать  dataframe с замененными NA. Ни порядок столбцов, ни порядок строк в dataframe изменять не нужно.

Вы можете создавать вспомогательные функции для решения этой задачи. 

```{r}
test_data <- as.data.frame(list(V1 = c(NA, NA, NA, NA, 13, 12, 9, 10, 8, 9, 11, 11, 10, 12, 9), V2 = c(NA, 12, 8, NA, 11, 11, 9, 8, 8, 10, 10, 11, 10, 10, 10), V3 = c(NA, 5, NA, 13, 12, 11, 11, 14, 8, 12, 8, 8, 10, 10, 8), V4 = c(10, 10, 10, 10, 13, 10, 11, 7, 12, 10, 7, 10, 13, 10, 9)))


na_rm <- function(x){
  result <- apply(x, 2, function(y){
  y[is.na(y)] <- mean(y, na.rm=T)
  return(y)
  })
  return(as.data.frame(result))
}

na_rm(test_data)

# Решение через ifelse

na_rm <- function(x){
  y <- apply(x,2,function(x) ifelse(is.na(x),mean(x,na.rm=T),x))
  return(as.data.frame(y))}

```

### lapply, sapply, tapply, by, vapply, mapply

В чём основная идея --- применяем некоторую функцию к объекту.

Почему их много? Потому что у apply  есть особенности:

* apply  нельзя применить к вектору, или дата.фрейму, списку

Для списков есть lapply

```{r}
my_list <- list(x = c(rnorm(30), NA), y = rnorm(10))
str(my_list)

#  она чувствительна к выбросам
lapply(my_list, mean) 

#  но можно так же через ... протаскивать аргументы функции
lapply(my_list, mean, na.rm = T)

#  основные идеи такие же --- можно писать функцию
lapply(my_list, function(x) x * 2)
```

Отличие 

* lapply всегда возвращает список той же длинны что и на входе.

* sapply упрощает вывод, пытается вернуть либо в виде вектора, либо в виде матрицы. И только если не получилось, возвращает в виде списка

```{r}
sapply(my_list, range, na.rm = T)
sapply(my_list, range, na.rm = T, simplify = F)
```

#### Задача

Напишите функцию positive_sum, которая получает на вход dataframe с произвольным количеством числовых переменных. Основная задача функции - найти сумму положительных значений в каждой переменной и сохранить их в список. Рассмотрим пример работы функции на небольшом примере:

Моё решение:

```{r}
positive_sum <- function(d){
  d <- apply(d, 2, function(x)(ifelse(x > 0, x, 0)))
  d <- as.data.frame(d)
  lapply(d, sum, na.rm = T)
}

positive_sum(d)
```

Гораздо более изящное решение, суммирование по индексам:

```{r}
positive_sum <- function(d) {
  lapply(d, function(x) sum(x[x>0], na.rm = T))
  }
```

### Практическая особенность sapply

Эти функции можно применять к вектору.

Есть задача, есть вектор с именами cars и есть какая-то машина с точным названием. Мы хотим понять, есть ли какая-то машина в векторе cars с таким же названием как и искомая машина

```{r}
cars <- c("Mazda", "Volga", "Merc")
car <- "Mazda RX4" 
```

Просто поэлементное сравнение ничего не даст. Но есть функция grepl(). Она проверяет, содержится ли первый вектор во втором

```{r}
grepl("Mazda", "Mazda RX4")
```

Наша задача понять является этот элемент 

```{r}
sapply(cars, function(x) grepl(x, car))
```

Так как это логический вектор, его можно использовать в качестве индексации

```{r}
cars[sapply(cars, function(x) grepl(x, car))]
```

Обратите внимание на следующее выражение, которое очень часто будет вам помогать при работе с данными:

давайте напишем команду, которая отбирает только количественные колонки в данных:

```{r}
iris_num <- iris[sapply(iris, is.numeric)]
```

Готово! sapply(iris, is.numeric) возвращает вектор логических значений, который мы и используем для индексации.

Этот пример также иллюстрирует идею, что lapply и sapply можно применять к dataframe. Так как dataframe - это в том числе и список.

Например, результат команды:

```{r}
sapply(iris[1:4], sd)
```

эквивалентна результату: 

```{r}
apply(iris[1:4], 2, sd)
```

так как каждая колонка dataframe - это и есть элемент списка, то функция lapply и sapply возвращает результат применения некоторой функции к каждой колонке данных!
Но тут есть одно но!

Как вы помните, apply производит все опперации именно над матрицами, поэтому если вы отправите в apply dataframe с разными типами данных, то R сначала приведет все колонки к одному типу, чтобы получилась матрица, т.к. в матрице могут храниться данные только одного типа! Это в свою очередь может привести к неожиданному результату:

```{r}
sapply(iris, is.numeric)

apply(iris, 2, is.numeric)
```

По результатам команды apply можно подумать, что в данных нет количественных переменных! Дело в том, что перед тем как применить функцию is.numeric, сначала данные iris были переведены в матрицу, а все переменные переведены в строки, как в наиболее общий тип данных. В результате получаем для каждой колонки FALSE.

Вот такой вот тонкий момент, о котором нужно помнить, применяя функцию apply к data.frame. В свою очередь с sapply и lapply такого не случится, т.к. в этом случае мы по очереди применим требуемую функцию к каждой колонке данных, как к каждому элементу списка! 

### Функция tapply. Спойлер --- aggregate лучше

Они не так встречаются. На вход принимает вектор, группирует по какому-то индексу, и применяет к этим группам функцию

```{r}
tapply(mtcars$mpg, mtcars$am, mean)
```

У этой функции есть более удобный аналог, функция aggregate

```{r}
aggregate(mpg ~ am, mtcars, mean)
```

Есть ещё функция by, которая группирует переменные

```{r}
by(iris[1:4], iris$Species, colMeans)
```

Как работает эта функция --- она берёт датафрейм ирис, и разбивает на несколько датафреймов в зависимости от перменной Species. Внутри функции by мы должны писать только те функции которые применимы к датафрейму

Можно к примеру написать такую функцию, которая проверяет на нормальность каждую количественную переменную, в зависимости от группирующей переменной.

```{r}
by(iris[1:4], iris$Species, 
   function(x) sapply(x, 
                      function(col) shapiro.test(col)$p.value))
```

Но не стоит на ней заостряться, функционал можно воспроизвести при помощи aggregate

```{r}
aggregate(. ~ Species, iris, function(x) shapiro.test(x)$p.value)
```

### Функция vapply

Такая же как lapply, только мы заранее говорим что хотим получить на выходе

```{r}
vapply(mtcars, mean, FUN.VALUE = numeric(1))
sapply(mtcars, mean)
```

Мы сообщаем на выходе, что хотим получить. Это ускоряет чисто вычислительный процесс

### Функция mapply

Она последовательно берёт элементы двух векторов и посылает их в функцию.

```{r}
mapply(rep, c(1, 2, 3, 4), c(1, 2, 3, 4))

rep(1, 3)
x <- c(20, 25, 13)
m <- c(0, 1, 2)
s <- c(3, 5, 6)
mapply(rnorm, x, m, s)
```


Допустим у нас есть матрица размером 100 на 200:

```{r}
m <- matrix(rnorm(100 * 200), nrow = 100)
```

И мы хотим присвоить имена строчкам и столбикам в этой матрице по принципу:

row_1, row_2, row_3, ..., row_100 - для строк

col_1, col_2, col_3, ..., col_200 - для колонок

Тогда мы могли бы сгенерировать список данными именами следующим образом:

```{r}
m_names <- mapply(paste, list("row", "col"), list(1:100, 1:200), sep = "_")
str(m_names)
```

### Подводный камень

Хотелось бы рассмотреть еще один подводный камень применения функций семейства apply к dataframe.

Предположим, мы решили написать простенькую функцию для расчета стандартного отклонения количественных переменных в данных.

```{r}
get_sd <- function(x){
  num_var <- sapply(x, is.numeric)
  sapply(x[, num_var], sd)
}
```

Казалось бы, все логично и работает на различных примерах:

```{r}
get_sd(iris)
```

Но в нашем коде скрыта серьезная уязвимость!) Предположим, у нас есть набор данных, в котором только одна количественная переменная:

```{r}
my_df <- data.frame(x = 1:10, y = letters[1:10])
get_sd(my_df)
```

Что вообще только что произошло? Дело в том, что существуют различные способы обращения к колонкам dataframe:

my_df[1] - получим dataframe

my_df[[1]] - получим вектор

my_df[, 1] - получим вектор

В случае, если у нас только одна количественная переменная, обращение x[, num_var] вернет колонку в виде вектора, а sapply применит функцию sd к каждому наблюдению вместо того, чтобы применить ко всей переменной.

Таким образом, если вы хотите применить какую-либо функцию к неизвестному заранее числу колонок в данных, лучше используйте такую индексацию типа: my_df[col_index]. То есть:

```{r}
get_sd <- function(x){
  num_var <- sapply(x, is.numeric)
  sapply(x[num_var], sd)}> get_sd(my_df)
```

также можно использовать параметр drop = FALSE при индексации (x[,num_var, drop = FALSE)
