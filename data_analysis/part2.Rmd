---
title: "data_analysis"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Этап 2

## Используемые библиотеки

```{r}
library(tidyverse)
```

## Функции семейства apply

### Основы

Возьмём встроенный набор данных

```{r}
data(diamonds)
str(diamonds)
```

Посмотрим минимальный размерность для каждого бриллианта

Через цикл:

```{r}
min_size <- c()

for (i in 1:nrow(diamonds)) {
  min_size <- c(min_size, min(diamonds[i, 8:10]))
}

head(min_size)
```

Это очень долго, в силу особенностей языка R. Можно ускорить, если сообщить какой тип данных будет у вектора, и сколько там будет значений. На каждом этапе сейчас мы перезаписываем.

```{r}
min_size <- c(nrow(diamonds))

for (i in 1:nrow(diamonds)) {
  min_size[i] <- min(diamonds[i, 8:10])
}
```

Теперь разберём правильный код. На всём протяжении работы с данными, мы будем применять к данным какие-то функции. Поэтому apply становится незаменимым фреймворком

```{r}
min_size <- apply(diamonds[, 8:10], 1, min) # 1 -- работая со строчками
```

Задача решена в одну строчку и очень быстро.

### Как работает

```{r}
apply(X, margin, ...)
```

X --- данные

MARGIN --- как рименяем функцию, по строчкам или по столбцам

FUN --- какая функция применяется

Потренируемся.

```{r}
d <- matrix(rnorm(30), nrow = 5)

apply(d, 1, sd)
```

apply взяла первую строчку данных, применила к ним sd. Потом вторую, и т.д. до конца.


```{r}
apply(d, 2, sd)
```

Всё тоже самое --- только к колнкам

### Задача

В переменной d сохранен dataframe с произвольным числом количественных переменных. При помощи функции apply найдите максимальное значение в каждой строке. Сохраните результат (вектор максимальных значений) в переменную row_max.

```{r}
row_max <- apply(d, 1, max)
```

### Как работает, продолжение

Если функция возвращает одно значение по результатам работы, то мы получаем вектор длинной по кол-ву строк или столбцов. Но что если функция возврщает несколько значений. Допустим функция range --- максимум и минимум

```{r}
my_range <- apply(d, 2, range)
```

Мы получаем не вектор, а матрицу.

А что если функция возвращает разное кол-во данных. Например Функция которая выводит только выбросы

```{r}
outliers_count <- function(x){
  outliers <- x[abs(x - mean(x)) > 2 * sd(x)]
  if (length(outliers) > 0) {
    return(outliers)
  } else {
    return("There are no outliers")
  }
}
```

Посмотрим есть ли выбросы в данных iris

```{r}
iris_num <-  iris[, 1:4]

apply(iris_num, 2, outliers_count)
```

Так как длины разные, то выходная запись --- лист с данными.

Apply --- инструмент, который хорошо заменяет цикл for.

### Многоточие

Через многоточие можно передавать аргументы используемой функции

```{r}
head(airquality)

apply(airquality, 2, mean)
```

Работает вот так

```{r}
apply(airquality, 2, mean, na.rm = T)
```

### Компактная функция --- можно прописывать функцию в теле apply

```{r}
set.seed(42)

d <- as.data.frame(matrix(rnorm(30), nrow = 5))

my_fun <- function(x) x * 2

```

Такая функция нигде не засветится.

Внутри функции apply можно записывать функцию. Это короткая функция

```{r}
apply(d, 2, function(x) x[x < 0])
```

### Задача

Давайте завершим и слегка модифицируем задачу из предыдущей лекции. Напишите функцию get_negative_values, которая получает на вход dataframe произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта переменная нас не интересует, для всех переменных, в которых есть отрицательные значения мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой переменной (смотри пример работы функции).

```{r}
test_data <- as.data.frame(list(V1 = c(NA, -0.5, -0.7, -8), V2 = c(-0.3, NA, -2, -1.2), V3 = c(1, 2, 3, NA)))

get_negative_values <- function(test_data){    
negative_col <- apply(test_data, 2, function(x) any(x[!is.na(x)] < 0))    
return(apply(test_data[negative_col], 2, function(x) x[!is.na(x) & x <0]))}
```

### Продолжение

Можно было бы применить дисперсионный анализ

```{r}
head(iris)
aov(Sepal.Length ~ Species, data = iris)
```

Но это делается только по одной переменной, давайте сделаем это для всех переменных
Берем только количественные перменные

```{r}
aov_result <- apply(iris[, 1:4], 2, function(x) aov(x ~ iris$Species))

norm_test <- apply(iris[, 1:4], 2, 
                   function(x) shapiro.test(x))


# Сразу достаём p.value
norm_test_p <- apply(iris[, 1:4], 2, 
                   function(x) shapiro.test(x)$p.value)

```

Этот код сделает сравнение трёх групп между собой по всем количественным перменным

Применяем статистический тест к нескольким параметрам

Для второй части по статистике --- p-уровень значимость

### Задача

Напишите функцию na_rm которая заменяет все пропущенные значения в столбцах dataframe на соответствующее среднее значение. То есть все NA в первом столбце заменяются на среднее значение первого столбца (рассчитанного без учета NA). Все NA второго столбца заменяются на среднее значение второго столбца и т.д.  Замена пропущенных значений на среднее. change NA to mean

Функция na_rm на вход получает dataframe произвольной размерности, состоящий из количественных переменных. Функция должна возвращать  dataframe с замененными NA. Ни порядок столбцов, ни порядок строк в dataframe изменять не нужно.

Вы можете создавать вспомогательные функции для решения этой задачи. 

```{r}
test_data <- as.data.frame(list(V1 = c(NA, NA, NA, NA, 13, 12, 9, 10, 8, 9, 11, 11, 10, 12, 9), V2 = c(NA, 12, 8, NA, 11, 11, 9, 8, 8, 10, 10, 11, 10, 10, 10), V3 = c(NA, 5, NA, 13, 12, 11, 11, 14, 8, 12, 8, 8, 10, 10, 8), V4 = c(10, 10, 10, 10, 13, 10, 11, 7, 12, 10, 7, 10, 13, 10, 9)))


na_rm <- function(x){
  result <- apply(x, 2, function(y){
  y[is.na(y)] <- mean(y, na.rm=T)
  return(y)
  })
  return(as.data.frame(result))
}

na_rm(test_data)

na_rm  <- function(x){    
	na_to_mean  <- function(v){    
		v[is.na(v)]  <- mean(v , na.rm = T)    
		return(v)}    
	result  <- as.data.frame(apply(x, 2, na_to_mean))}



```

