---
title: "data_analysis"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(Hmisc)
```

Обновление

```{r}
# install.packages("Hmisc")
# library(installr)
# updateR()
```


# Этап 1

## Общая информация о курсе

Тут всё понятно. Двигаем дальше

## Переменные

Ознакомительные этапы. Всё просто. Ответ на задачу:


```{r}
# my_vector_2 <- my_vector[my_vector > (mean(my_vector) - sd(my_vector)) & my_vector < (mean(my_vector) + sd(my_vector))]
```

## Работа с data frame

### Задача

Ваша задача создать новый `dataframe` под названием `mini_mtcars`, в котором будут сохранены только третья, седьмая, десятая, двенадцатая и последняя строчка датафрейма `mtcars`.

```{r}
mini_mtcars <- mtcars[c(3, 7, 10, 12, length(mtcars$mpg)), ]
```

### Задача

В этой задче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную) под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное. 

```{r}
mtcars$even_gear <- as.numeric(mtcars$gear %% 2 == 0)
```

### Задача

Продолжим нашу работу с данными mtcars. Теперь ваша задача создать переменную - вектор mpg_4 и сохранить в нее значения расхода топлива (mpg) для машин с четырьмя цилиндрами (cyl). 

```{r}
mpg_4 <- mtcars$mpg[mtcars$cyl == 4]

factorial(43) / (factorial(8) * factorial(43-8))
factorial(43) / (factorial(6) * factorial(43-6))

```


## Элементы синтаксиса

Введём тестовый набор данных

```{r}
mydata <- read.csv("evals.csv")
```


```{r}
mydata$quality <- rep(NA, nrow(mydata))
```


```{r}
for (i in 1:nrow(mydata)){
  if (mydata$score[i] > 4){
    mydata$quality[i] <- "good"
  } else mydata$quality[i] <- "bad"
}
```

### Задача

Создайте новую числовую переменную  `new_var` в данных `mtcars`, которая содержит единицы в строчках, если в машине не меньше четырёх карбюраторов (переменная "carb") или больше шести цилиндров (переменная "cyl"). В строчках, в которых условие не выполняется, должны стоять нули.

```{r}
for (i in 1:nrow(mtcars)) {
  if (mtcars$carb[i] >= 4 || mtcars$cyl[i] > 6){
    mtcars$new_var[i] <- 1
  } else mtcars$new_var[i] <- 0
}
```

### Задача

```{r}
my_vector <- 1:50
```


Если среднее значение вектора `my_vector` больше 20, в переменную `result` сохраните "My mean is great",  если среднее значение `my_vector` меньше или равно 20 то в переменную `result` сохраните  строку "My mean is not so great".

```{r}
if(mean(my_vector) > 20){
result <- "My mean is great"
} else {
  result <- "My mean is not so great"
}
```

### Задача

В встроенных в R данных AirPassengers хранится 144 значения (количество пассажиров в месяц) с 1949 по 1960 год. Данные Time-Series очень похожи на вектор по своей структуре, например мы можем обратиться к любому из 144 элементов используя уже знакомую нам индексацию AirPassengers[1] или AirPassengers[56].

Можно вообще перевести исходные данные в вектор при помощи команды as.vector(AirPassengers) и продолжить с ними работу как с вектором.

И так ваша задача создать переменную good_months и сохранить в нее число пассажиров только в тех месяцах, в которых это число больше, чем показатель в предыдущем месяце.  

Важный момент! В R оператор : для создания последовательности имеет приоритет над арифметическими действиями. Таким образом, если у вас есть переменная i, равная 10, и вы хотите создать вектор от 1 до i - 1, воспользуйтесь скобками, чтобы указать последовательность действий.

```{r}
?AirPassengers # справка о данных
str(AirPassengers) # структура данных
```

```{r}
(fit <- arima(log10(AirPassengers), c(0, 1, 1),
              seasonal = list(order = c(0, 1, 1), period = 12)))
update(fit, method = "CSS")
update(fit, x = window(log10(AirPassengers), start = 1954))
pred <- predict(fit, n.ahead = 24)
tl <- pred$pred - 1.96 * pred$se
tu <- pred$pred + 1.96 * pred$se
ts.plot(AirPassengers, 10^tl, 10^tu, log = "y", lty = c(1, 2, 2))
```

Моё решение:

```{r}
length(AirPassengers) 

AirPassengers[1] < AirPassengers[145]

good_months<-c()
for (i in 1:(length(AirPassengers)-1)) {
  if (AirPassengers[i+1]>AirPassengers[i]) {
    good_months<-append(good_months,AirPassengers[i+1]) 
  }
}
```

Более ровное решение с циклом

```{r}
good_months <- c()    
index <- 1    
for (i in 2:length(AirPassengers)) {    
	if (AirPassengers[i]>AirPassengers[i-1]){    
		good_months[index] <- AirPassengers[i]    
		index <- index + 1    
		}    
	}
```

Очень красивое решение, без цикла

```{r}
good_months <- AirPassengers[-1][AirPassengers[-1] > AirPassengers[-144]]
```

Разберём его. 
Делаем два вектора. 
Первый `AirPassengers[-1]` --- вектор без первого значения
Второй `AirPassengers[-144]` --- вектор без последнего значения
Далее мы сравниваем значение с его последующим значением.

При сравнении, мы получаем логический вектор

```{r}
AirPassengers[-1] > AirPassengers[-144]
```

Далее, чтобы получить обратно значения, нужно в исходном векторе без первого значения взять `TRUE` индексы

### Задача

Для встроенных в R данных AirPassengers рассчитайте скользящее среднее с интервалом сглаживания равным 10. Напечатайте получившийся результат (первым значением в выводе должно быть среднее для элементов 1:10, во втором значении - среднее для элементов 2:11 и т.д., в последнем  - среднее для элементов 135 :144)

Все полученные значения средних сохраните в переменную moving_average.


Моё решение:
```{r}
x <- c(2, 4, 7)
y <- c(2, 3, 5)
x - y
cumsum(x)
cumsum(1:10)
as.vector(AirPassengers)

moving_average <- (cumsum(AirPassengers)[10:144] - c(0, cumsum(AirPassengers[1:134]))) / 10
```


В общем виде:

```{r}
n <- 10    
d <- AirPassengers    
cx <- c(0, cumsum(d))    
moving_average <- (cx[(n + 1):length(cx)] - cx[1:(length(cx) - n)]) / n
```

Можно через цикл:

```{r}
moving_average <- numeric(135) # создаем пустой числовой вектор из 135 элементов    
last_index <- length(AirPassengers) - 9    
for (i in 1:last_index) {    
	end <- i + 9    
	moving_average[i] <- mean(AirPassengers[i:end])    
}
```


## Описательные статистики

`aggregate()` --- позволяет разбивать на группы.

```{r}
mean_hp_vs <- aggregate(x = mtcars$hp, by = list(mtcars$vs), FUN = mean)
colnames(mean_hp_vs) <- c("VS", "Mean HP")
mean_hp_vs
```

Короткая запись выглядит вот так

```{r}
aggregate(hp ~ vs, mtcars, mean)
```

Разбиение по двум переменным

```{r}
aggregate(hp ~ vs + am, mtcars, mean)
```

Есть библиотека `psych` в которой есть джентельменский набор большинства описательных статистик

```{r}
# install.packages("psych")
library(psych)
```

Итак опистельные статистики в одном флаконе

```{r}
descr <- describe(x = mtcars[, -c(8,9)])
```

Более новая версия `describeBy`

```{r}
descr2 <- describeBy(x = mtcars[, -c(8,9)], group = mtcars$vs) # В выводе лист

descr2 <- describeBy(x = mtcars[, -c(8,9)], group = mtcars$vs, mat = TRUE, digits = 1) # В выводе матрица, с одни знаком после запятой
```

Можно сократить вывод до кол-ва базовых статистик

```{r}
descr3 <- describeBy(x = mtcars[, -c(8,9)], group = mtcars$vs, mat = TRUE, digits = 1, fast = TRUE)
```



### Задача

Вновь вернемся к данным `mtcars`. Рассчитайте среднее значение времени разгона `qsec` для автомобилей, число цилиндров `cyl` у которых не равняется 3 и показатель количества миль на галлон топлива `mpg` больше 20.

Получившийся результат (среднее значение) сохраните в переменную `result`.

```{r}
result <- mean(mtcars$qsec[mtcars$cyl != 3 & mtcars$mpg > 20])
```

### Задача

При помощи функции aggregate рассчитайте стандартное отклонение переменной hp (лошадиные силы) и переменной disp (вместимости двигателя)  у машин с автоматической и ручной коробкой передач. 

Полученные результаты (результаты выполнения функции aggregate) сохраните в переменную descriptions_stat.

```{r}
descriptions_stat <- aggregate(x = mtcars[, c("hp", "disp")], by = list(mtcars$am), FUN = sd)
```

Вот чуть более изящное применение 

```{r}
descriptions_stat <- aggregate(. ~ mtcars$am,mtcars[,c(3,4)],sd)
```

### Задача

Примените функцию describeBy к количественным переменным данных airquality, группируя наблюдения по переменной Month.  Чему равен коэффициент асимметрии (skew) переменной Wind в восьмом месяце?

В графу с ответом требуется ввести только число. Десятичный разделитель - запятая: например 12,6

```{r}
describeBy(x = airquality$Wind, group = airquality$Month)
```


### Задача

Обратимся к встроенным данным iris. Соотнесите значения стандартного отклонения переменных.

```{r}
iris
describeBy(x = iris)
```

### Задача

В данных iris расположите по убыванию значения медиан количественных переменных в группе virginica.

```{r}
describeBy(x = iris, group = iris$Species)
```

### Задача

Воспользуемся встроенными данными airquality. В новую переменную сохраните subset исходных данных, оставив наблюдения только для месяцев 7, 8 и 9.

При помощи функции aggregate рассчитайте количество непропущенных наблюдений по переменной Ozone в 7, 8 и 9 месяце. Для определения количества наблюдений используйте функцию length(). 

Результат выполнения функции aggregate сохраните в переменную result.

```{r}
# Это выражение считает и пропущенные значения тоже
aggregate(x = new_airquality[, "Ozone"], by = list(new_airquality$Month), length)

# Это выражение не считает пропущенные значения
aggregate(Ozone ~ Month, subset(airquality, Month > 6), length)
```

### Задача

В переменной my_vector сохранен вектор с пропущенными значениями. Вам нужно создать новый вектор fixed_vector, в котором все пропущенные значения вектора my_vector будут заменены на среднее значение по имеющимся наблюдениям.

При этом исходный вектор оставьте без изменений!

Напоминаю, переменная my_vector уже создана, сразу начинайте работать с ней. Перед тем, как сдавать решение, вы можете потренироваться на различных примерах. Ниже небольшой код, который может создать случайный вектор (выборка из нормального распределения) с пропущенными значениями.

```{r}
my_vector <- rnorm(30)
my_vector[sample(1:30, 10)] <- NA

replace(my_vector, is.na(my_vector), mean(my_vector, na.rm = TRUE))
```

## Описательные статистики. Графики

Базовые графики

```{r}
hist(mtcars$mpg, breaks = 20, xlab = "MPG")
boxplot(mtcars, mpg ~ am)
plot(mtcars$mpg, mtcars$disp)
```

но лучше строить в пакете `ggplot2`.
Вот допустим гистограммы

```{r}
ggplot(mtcars, aes(x = mpg)) +
  geom_histogram(fill = "white", color = "black", binwidth = 2)
```

Вот допустим плотность

```{r}
ggplot(mtcars, aes(x = mpg, fill = factor(am))) +
  geom_density(alpha = 0.6)
```

Ещё пару графиков

```{r}
ggplot(mtcars, aes(x = factor(am), y = hp, color = factor(vs))) +
  geom_boxplot()
```

### Задача

При помощи функции ggplot() или boxplot() постройте график boxplot, используя встроенные в R данные airquality. По оси x отложите номер месяца, по оси y — значения переменной Ozone.

На графике boxplot отдельными точками отображаются наблюдения, отклоняющиеся от 1 или 3 квартиля больше чем на полтора межквартильных размаха. Сколько таких наблюдений присутствует в сентябре (месяц №9)?

```{r}
ggplot(airquality, aes(factor(Month), Ozone)) +
  geom_boxplot()
```


### Задача

Используем знакомые нам данные mtcars. 

Нужно построить scatterplot с помощью ggplot из ggplot2, по оси x которого будет mpg, по оси y - disp, а цветом отобразить переменную (hp).

Полученный график нужно сохранить в переменную plot1. Таким образом в ответе должен быть скрипт:

```{r}
plot1 <- ggplot(mtcars, aes(mpg, disp, color = hp)) +
  geom_point()
```

### Задача

Немного гистограмм с ирисами

```{r}
ggplot(iris, aes(Sepal.Length, fill = Species)) + geom_histogram()
ggplot(iris, aes(Sepal.Length)) + geom_histogram(aes(fill = Species))
```

### Задача

Студент Ярослав очень любит строить графики в R. Основываясь на данных iris он хочет построить следующий график:

Scatterplot (диаграмма рассеивания), где по оси X будет отложена переменная Sepal.Length,  по оси Y переменная  Sepal.Width. За цвет точек будет отвечать переменная  Species, а за размер точек переменная Petal.Length.


```{r}
ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species, size = Petal.Length)) +
  geom_point()

ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point(aes(color = Species, size = Petal.Length))
```

## Анализ номинативных данных

Данные для работы на этом уроке

```{r}
df <- read_csv("grants.csv")

# сделаем замены на фактор и понятные описания
df$status <- as.factor(df$status)
levels(df$status) <- c("Not funded", "Funded")

df$status <- factor(df$status, labels = c("Not funded", "Funded"))

str(df)

# 1d table
t1 <-  table(df$status)

# 2d table
t2 <- table(df$status, df$field)

prop.table(t2)

# 3d table

t3 <- table(Years = df$years_in_uni, Field = df$field, Status = df$status)

dim(t3)
```

Тесты

```{r}
chisq.test(t2)

fisher.test(t2)
```




### Задача

Ваша задача в переменную red_men сохранить долю рыжеволосых (Red) от общего числа голубоглазых мужчин.

```{r}
HairEyeColor
dimnames(HairEyeColor)

# only man
prop.table(HairEyeColor[ , ,'Male'], 2)['Red', 'Blue']
```

* создаем двумерную таблицу, 2- группировка значений по столбцу `prop.table(HairEyeColor[ , ,'Male'], 2)`

* обращаемся к ее х/у `['Red', 'Blue']`

### Задача

Напишите число зеленоглазых женщин в наборе данных HairEyeColor.

```{r}
as.data.frame(HairEyeColor) %>%
  group_by(Sex, Eye) %>%
  summarise(sum = sum(Freq)) %>%
  filter(Sex == "Female", Eye == "Green")
```


### Задача

Какой запрос будет возвращать 1,2 и 5 столбец данных

```{r}
df <- tibble(
  first_name = 1,
  last_name = 2,
  email_address = 3,
  postal_address = 4,
  date_added = 5
)

df

select(df, -(3:4))

df %>% select(c(1:2, 5))
select(df, matches("_.{4,5}$"))
select(df, contains("name"), date_added)
select(df, first_name, last_name, date_added)
```


### Задача

Постройте столбчатую диаграмму распределения цвета глаз по цвету волос только у женщин из 
таблицы HairEyeColor. По оси X должен идти цвет волос, цвет столбиков должен отражать цвет глаз. По оси Y - количество наблюдений.

```{r}
mydata <- as.data.frame(HairEyeColor)

ggplot(data = subset(mydata, Sex == 'Female'), aes(x = Hair , y = Freq, fill = Eye)) + 
  geom_bar(stat="identity", position = "dodge")
```

### Задача

На основе таблицы HairEyeColor создайте ещё одну таблицу, в которой хранится информация о распределении цвета глаз у женщин-шатенок (Hair = 'Brown'). Проведите тест равномерности распределения цвета глаз у шатенок и выведите значение хи-квадрата для этого теста.

```{r}
chisq.test(HairEyeColor["Brown", ,"Female"])
```

### Задача

Воспользуемся данными diamonds из библиотеки ggplot2. При помощи критерия Хи - квадрат проверьте гипотезу о взаимосвязи качества огранки бриллианта (сut) и его цвета (color). В переменную main_stat сохраните значение статистики критерия Хи - квадрат. Обратите внимание, main_stat должен быть вектором из одного элемента, а не списком (листом).


```{r}
main_stat <- chisq.test(as.matrix(diamonds[, 2]), as.matrix(diamonds[, 3]))[1]
```

Задаю критерии X и Y через обращение к индексам элементов в наборе данных diamonds. Затем, чтобы результат возвращался вектором из одного элемента обращаюсь к первому элементу списка результата выполнения функции chisq.test

### Задача

Опять воспользуемся данными diamonds из библиотеки ggplot2. При помощи критерия Хи - квадрат проверьте гипотезу о взаимосвязи цены (price) и каратов (carat) бриллиантов. Для этого сначала нужно перевести эти количественные переменные в формат пригодный для Хи - квадрат. Создайте две новые переменные в данных diamonds:

factor_price - где будет 1, если значение цены больше либо равно чем среднее, и 0, если значение цены ниже среднего цены по выборке.

factor_carat - где будет 1, если число карат больше либо равно чем среднее,  и 0, если ниже среднего числа карат по выборке.

Важный момент - на больших данных цикл for() работает довольно медленно, постарайтесь решить эту задачу без его использования!

Используя эти шкалы при помощи Хи - квадрат проверьте исходную гипотезу. Сохраните в переменную main_stat значение критерия  Хи - квадрат.

```{r}
factor_price <- ifelse(diamonds$price >= mean(diamonds$price), 1, 0)
factor_carat <- ifelse(diamonds$carat >= mean(diamonds$carat), 1, 0)
  
main_stat <- chisq.test(factor_price, factor_carat)[1]
  
diamonds %>%
  select("price") %>% 
  summarise(mean = mean(price))
```

### Задача

При помощи точного критерия Фишера проверьте гипотезу о взаимосвязи типа коробки передач (am) и типа двигателя (vs) в данных mtcars. Результат выполнения критерия сохраните в переменную.Получившийся p - уровень значимости сохраните в переменную fisher_test.


```{r}
fisher_test <- fisher.test(mtcars$am, mtcars$vs)[1]
```

## Сравнение двух групп

Будем сравнивать две группы в ирисах

```{r}
# Отберём две группы из встроенного набора данных
df <- iris
df1 <- subset(df, Species != "setosa")
table(df1$Species)


# Посмотрим как распределяются две группы
ggplot(df1, aes(x = Sepal.Length)) +
  geom_histogram(fill = "white", col = "black", binwidth = 0.4) +
  facet_grid(Species ~ .)

ggplot(df1, aes(Sepal.Length, fill = Species)) +
  geom_density(alpha = 0.5)

# Посмотрим, есть ли выбросы в данных 
ggplot(df1, aes(Species, Sepal.Length)) +
  geom_boxplot()
```

Теперь посмотрим на сколько значимы различия. Для этого сначала надо убедиться в нормальности распределения параметров.

```{r}
shapiro.test(df1$Sepal.Length)
```

p-value уровень значимость превышает 0.05 --- можем сделать вывод что по всей выборке распредление переменной не отличается от нормального.

```{r}
# Базовый синтаксис
shapiro.test(df1$Sepal.Length[df1$Species == "versicolor"])
shapiro.test(df1$Sepal.Length[df1$Species == "virginica"])
```

2. Разберём второе ограничение --- гомогенность дисперсий

```{r}
bartlett.test(Sepal.Length ~ Species, df1)
```

p-value уровень значимость превышает 0.05 --- гомогенность дисперсий подтверждена

Теперь выполним t-test 

```{r}
t.test(Sepal.Length ~ Species, df1)
```

p-value уровень значимость сильно меньше 0.05 --- отвергаем нулевую гипотезу о равенстве средних

```{r}
test1 <- t.test(Sepal.Length ~ Species, df1)
str(test1)
# Чтобы обратится к конкретно p-value
test1$p.value
```

Нулевая гипотеза --- длина и ширина лепестка равны между собой

```{r}
t.test(df1$Petal.Length, df1$Petal.Width, paired = TRUE)
```

![](img/cheetsheet.png)
Мы хотим построить на графике саму переменную с указанием доверительных интервалов и среднего.

```{r}
ggplot(df1, aes(Species, Sepal.Length)) + 
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.1) +
  stat_summary(fun.y = mean, geom = "point", size = 4)
  
```


непараметрический аналог т.теста. 

```{r}
wilcox.test(Petal.Length ~ Species, df1)
```

и график по нему

```{r}
ggplot(df1, aes(Species, Petal.Length)) + 
  geom_boxplot()
```

Выполним wilcox.test для двух зависимых переменных

```{r}
wilcox.test(df1$Petal.Length, df1$Petal.Width, paired = T)
```

Отклоняем

### Задача

Воспользуемся еще одним встроенным набором данных в R  - ToothGrowth. Данные позволяют исследовать рост зубов у морских свинок в зависимости от дозировки витамина C и типа потребляемых продуктов.

Сравните среднее значение длины зубов свинок, которые потребляли апельсиновый сок (OJ) с дозировкой 0.5 миллиграмм, со средним значением длины зубов свинок, которые потребляли аскорбиновую кислоту (VC) с дозировкой 2 миллиграмма. 

```{r}
# уфф решение в лоб
t_stat <- t.test(ToothGrowth$len[ToothGrowth$supp == "OJ"][ToothGrowth$dose == 0.5][!is.na(ToothGrowth$len[ToothGrowth$supp == "OJ"][ToothGrowth$dose == 0.5])], ToothGrowth$len[ToothGrowth$supp == "VC"][ToothGrowth$dose == 2.0][!is.na(ToothGrowth$len[ToothGrowth$supp == "VC"][ToothGrowth$dose == 2.0])])$statistic

# а вот как по уму надобно сделать. Повторяй индексацию
correct_data <- subset(ToothGrowth, supp=='OJ' & dose==0.5 | supp=='VC' & dose==2)    
t_stat <- t.test(len ~ supp, correct_data)$statistic
```


### Задача

По всем испытуемым сравните показатель давления до начала лечения (Pressure_before) с показателем давления после лечения (Pressure_after) при помощи t - критерия для зависимых выборок. 

В поле для ответа укажите значение t - критерия.

(В качестве десятичного разделителя используйте запятую, например: 123,54)

```{r}
drugs <- read.csv("lekarstva.csv")

str(drugs)

t.test(drugs$Pressure_before, drugs$Pressure_after, paired = TRUE)[1]

```


### Задача

Сначала с помощью теста Бартлетта проверьте гомогенность дисперсий двух выборок. В случае, если дисперсии значимо не отличаются (с уровнем 0.05), примените тест Стьюдента, иначе - непараметрический тест (Манна-Уитни). В поле для ответа введите получившийся p-value, с точностью четыре знака после запятой.
Обратите внимание, что по умолчанию в t.test стоит var.equal = FALSE, так как мы будем применять его только в случае гомогенности дисперсий, измените значение этого параметра на  var.equal = TRUE.

```{r}
t <- read.table("dataset_11504_15.txt")

bartlett.test(V1 ~ V2, t)

wilcox.test(V1 ~ V2, t)
# t.test(V1 ~ V2, t, var.equal = TRUE)
```


Если првоерка на гомогенность при тесте Бартлетта p-value почти равна 0,05 ---  дисперсии значимо различаются. Надо применять непараметрический тест Манна-Уитни `wilcox.test()`

### Задача

В данных сохранены две количественные переменные, проверьте гипотезу о равенстве средних этих переменных при помощи t- теста для независимых выборок.

Если обнаружены значимые различия (p< 0.05), то введите через пробел три числа: среднее значение первой переменной, среднее значение второй переменной, p - уровень значимости. Например:

22.45 12.56 0.04

Если значимые различия не обнаружены, то в поле для ответа введите: 

`"The difference is not significant"`

В этой задаче оставьте var.equal = FALSE

```{r}


t.test(V1 ~ V2, s, var.equal = FALSE)[3]
```



```{r}
df <- read.table("dataset_11504_16.txt")
p <- bartlett.test(df)$p.value
if (p < 0.05) {
  p_res <- t.test(df$V1, df$V2)
  cat(paste(c(sapply(df,mean), p_res$p.value), collapse = "\n"))
} else {
  "The difference is not significant"
}
```

