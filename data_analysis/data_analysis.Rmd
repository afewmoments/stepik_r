---
title: "data_analysis"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
```

Обновление

```{r}
# install.packages("installr")
# library(installr)
# updateR()
```


# Этап 1

## Общая информация о курсе

Тут всё понятно. Двигаем дальше

## Переменные

Ознакомительные этапы. Всё просто. Ответ на задачу:


```{r}
# my_vector_2 <- my_vector[my_vector > (mean(my_vector) - sd(my_vector)) & my_vector < (mean(my_vector) + sd(my_vector))]
```

## Работа с data frame

### Задача

Ваша задача создать новый `dataframe` под названием `mini_mtcars`, в котором будут сохранены только третья, седьмая, десятая, двенадцатая и последняя строчка датафрейма `mtcars`.

```{r}
mini_mtcars <- mtcars[c(3, 7, 10, 12, length(mtcars$mpg)), ]
```

### Задача

В этой задче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную) под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное. 

```{r}
mtcars$even_gear <- as.numeric(mtcars$gear %% 2 == 0)
```

### Задача

Продолжим нашу работу с данными mtcars. Теперь ваша задача создать переменную - вектор mpg_4 и сохранить в нее значения расхода топлива (mpg) для машин с четырьмя цилиндрами (cyl). 

```{r}
mpg_4 <- mtcars$mpg[mtcars$cyl == 4]

factorial(43) / (factorial(8) * factorial(43-8))
factorial(43) / (factorial(6) * factorial(43-6))

```


## Элементы синтаксиса

Введём тестовый набор данных

```{r}
mydata <- read.csv("evals.csv")
```


```{r}
mydata$quality <- rep(NA, nrow(mydata))
```


```{r}
for (i in 1:nrow(mydata)){
  if (mydata$score[i] > 4){
    mydata$quality[i] <- "good"
  } else mydata$quality[i] <- "bad"
}
```

### Задача

Создайте новую числовую переменную  `new_var` в данных `mtcars`, которая содержит единицы в строчках, если в машине не меньше четырёх карбюраторов (переменная "carb") или больше шести цилиндров (переменная "cyl"). В строчках, в которых условие не выполняется, должны стоять нули.

```{r}
for (i in 1:nrow(mtcars)) {
  if (mtcars$carb[i] >= 4 || mtcars$cyl[i] > 6){
    mtcars$new_var[i] <- 1
  } else mtcars$new_var[i] <- 0
}
```

### Задача

```{r}
my_vector <- 1:50
```


Если среднее значение вектора `my_vector` больше 20, в переменную `result` сохраните "My mean is great",  если среднее значение `my_vector` меньше или равно 20 то в переменную `result` сохраните  строку "My mean is not so great".

```{r}
if(mean(my_vector) > 20){
result <- "My mean is great"
} else {
  result <- "My mean is not so great"
}
```

### Задача

В встроенных в R данных AirPassengers хранится 144 значения (количество пассажиров в месяц) с 1949 по 1960 год. Данные Time-Series очень похожи на вектор по своей структуре, например мы можем обратиться к любому из 144 элементов используя уже знакомую нам индексацию AirPassengers[1] или AirPassengers[56].

Можно вообще перевести исходные данные в вектор при помощи команды as.vector(AirPassengers) и продолжить с ними работу как с вектором.

И так ваша задача создать переменную good_months и сохранить в нее число пассажиров только в тех месяцах, в которых это число больше, чем показатель в предыдущем месяце.  

Важный момент! В R оператор : для создания последовательности имеет приоритет над арифметическими действиями. Таким образом, если у вас есть переменная i, равная 10, и вы хотите создать вектор от 1 до i - 1, воспользуйтесь скобками, чтобы указать последовательность действий.

```{r}
?AirPassengers # справка о данных
str(AirPassengers) # структура данных
```

```{r}
(fit <- arima(log10(AirPassengers), c(0, 1, 1),
              seasonal = list(order = c(0, 1, 1), period = 12)))
update(fit, method = "CSS")
update(fit, x = window(log10(AirPassengers), start = 1954))
pred <- predict(fit, n.ahead = 24)
tl <- pred$pred - 1.96 * pred$se
tu <- pred$pred + 1.96 * pred$se
ts.plot(AirPassengers, 10^tl, 10^tu, log = "y", lty = c(1, 2, 2))
```

Моё решение:

```{r}
length(AirPassengers) 

AirPassengers[1] < AirPassengers[145]

good_months<-c()
for (i in 1:(length(AirPassengers)-1)) {
  if (AirPassengers[i+1]>AirPassengers[i]) {
    good_months<-append(good_months,AirPassengers[i+1]) 
  }
}
```

Более ровное решение с циклом

```{r}
good_months <- c()    
index <- 1    
for (i in 2:length(AirPassengers)) {    
	if (AirPassengers[i]>AirPassengers[i-1]){    
		good_months[index] <- AirPassengers[i]    
		index <- index + 1    
		}    
	}
```

Очень красивое решение, без цикла

```{r}
good_months <- AirPassengers[-1][AirPassengers[-1] > AirPassengers[-144]]
```

Разберём его. 
Делаем два вектора. 
Первый `AirPassengers[-1]` --- вектор без первого значения
Второй `AirPassengers[-144]` --- вектор без последнего значения
Далее мы сравниваем значение с его последующим значением.

При сравнении, мы получаем логический вектор

```{r}
AirPassengers[-1] > AirPassengers[-144]
```

Далее, чтобы получить обратно значения, нужно в исходном векторе без первого значения взять `TRUE` индексы

### Задача

Для встроенных в R данных AirPassengers рассчитайте скользящее среднее с интервалом сглаживания равным 10. Напечатайте получившийся результат (первым значением в выводе должно быть среднее для элементов 1:10, во втором значении - среднее для элементов 2:11 и т.д., в последнем  - среднее для элементов 135 :144)

Все полученные значения средних сохраните в переменную moving_average.


Моё решение:
```{r}
x <- c(2, 4, 7)
y <- c(2, 3, 5)
x - y
cumsum(x)
cumsum(1:10)
as.vector(AirPassengers)

moving_average <- (cumsum(AirPassengers)[10:144] - c(0, cumsum(AirPassengers[1:134]))) / 10
```


В общем виде:

```{r}
n <- 10    
d <- AirPassengers    
cx <- c(0, cumsum(d))    
moving_average <- (cx[(n + 1):length(cx)] - cx[1:(length(cx) - n)]) / n
```

Можно через цикл:

```{r}
moving_average <- numeric(135) # создаем пустой числовой вектор из 135 элементов    
last_index <- length(AirPassengers) - 9    
for (i in 1:last_index) {    
	end <- i + 9    
	moving_average[i] <- mean(AirPassengers[i:end])    
}
```


## Описательные статистики

`aggregate()` --- позволяет разбивать на группы.

```{r}
mean_hp_vs <- aggregate(x = mtcars$hp, by = list(mtcars$vs), FUN = mean)
colnames(mean_hp_vs) <- c("VS", "Mean HP")
mean_hp_vs
```

Короткая запись выглядит вот так

```{r}
aggregate(hp ~ vs, mtcars, mean)
```

Разбиение по двум переменным

```{r}
aggregate(hp ~ vs + am, mtcars, mean)
```

Есть библиотека `psych` в которой есть джентельменский набор большинства описательных статистик

```{r}
# install.packages("psych")
library(psych)
```

Итак опистельные статистики в одном флаконе

```{r}
descr <- describe(x = mtcars[, -c(8,9)])
```

Более новая версия `describeBy`

```{r}
descr2 <- describeBy(x = mtcars[, -c(8,9)], group = mtcars$vs) # В выводе лист

descr2 <- describeBy(x = mtcars[, -c(8,9)], group = mtcars$vs, mat = TRUE, digits = 1) # В выводе матрица, с одни знаком после запятой
```

Можно сократить вывод до кол-ва базовых статистик

```{r}
descr3 <- describeBy(x = mtcars[, -c(8,9)], group = mtcars$vs, mat = TRUE, digits = 1, fast = TRUE)
```



### Задача

Вновь вернемся к данным `mtcars`. Рассчитайте среднее значение времени разгона `qsec` для автомобилей, число цилиндров `cyl` у которых не равняется 3 и показатель количества миль на галлон топлива `mpg` больше 20.

Получившийся результат (среднее значение) сохраните в переменную `result`.

```{r}
result <- mean(mtcars$qsec[mtcars$cyl != 3 & mtcars$mpg > 20])
```

### Задача

При помощи функции aggregate рассчитайте стандартное отклонение переменной hp (лошадиные силы) и переменной disp (вместимости двигателя)  у машин с автоматической и ручной коробкой передач. 

Полученные результаты (результаты выполнения функции aggregate) сохраните в переменную descriptions_stat.

```{r}
descriptions_stat <- aggregate(x = mtcars[, c("hp", "disp")], by = list(mtcars$am), FUN = sd)
```

Вот чуть более изящное применение 

```{r}
descriptions_stat <- aggregate(. ~ mtcars$am,mtcars[,c(3,4)],sd)
```

### Задача

Примените функцию describeBy к количественным переменным данных airquality, группируя наблюдения по переменной Month.  Чему равен коэффициент асимметрии (skew) переменной Wind в восьмом месяце?

В графу с ответом требуется ввести только число. Десятичный разделитель - запятая: например 12,6

```{r}
describeBy(x = airquality$Wind, group = airquality$Month)
```


### Задача

Обратимся к встроенным данным iris. Соотнесите значения стандартного отклонения переменных.

```{r}
iris
describeBy(x = iris)
```

### Задача

В данных iris расположите по убыванию значения медиан количественных переменных в группе virginica.

```{r}
describeBy(x = iris, group = iris$Species)
```

### Задача

Воспользуемся встроенными данными airquality. В новую переменную сохраните subset исходных данных, оставив наблюдения только для месяцев 7, 8 и 9.

При помощи функции aggregate рассчитайте количество непропущенных наблюдений по переменной Ozone в 7, 8 и 9 месяце. Для определения количества наблюдений используйте функцию length(). 

Результат выполнения функции aggregate сохраните в переменную result.

```{r}
# Это выражение считает и пропущенные значения тоже
aggregate(x = new_airquality[, "Ozone"], by = list(new_airquality$Month), length)

# Это выражение не считает пропущенные значения
aggregate(Ozone ~ Month, subset(airquality, Month > 6), length)
```

### Задача

В переменной my_vector сохранен вектор с пропущенными значениями. Вам нужно создать новый вектор fixed_vector, в котором все пропущенные значения вектора my_vector будут заменены на среднее значение по имеющимся наблюдениям.

При этом исходный вектор оставьте без изменений!

Напоминаю, переменная my_vector уже создана, сразу начинайте работать с ней. Перед тем, как сдавать решение, вы можете потренироваться на различных примерах. Ниже небольшой код, который может создать случайный вектор (выборка из нормального распределения) с пропущенными значениями.

```{r}
my_vector <- rnorm(30)
my_vector[sample(1:30, 10)] <- NA

replace(my_vector, is.na(my_vector), mean(my_vector, na.rm = TRUE))
```

## Описательные статистики. Графики

Базовые графики

```{r}
hist(mtcars$mpg, breaks = 20, xlab = "MPG")
boxplot(mtcars, mpg ~ am)
plot(mtcars$mpg, mtcars$disp)
```

но лучше строить в пакете `ggplot2`.
Вот допустим гистограммы

```{r}
ggplot(mtcars, aes(x = mpg)) +
  geom_histogram(fill = "white", color = "black", binwidth = 2)
```

Вот допустим плотность

```{r}
ggplot(mtcars, aes(x = mpg, fill = factor(am))) +
  geom_density(alpha = 0.6)
```

Ещё пару графиков

```{r}
ggplot(mtcars, aes(x = factor(am), y = hp, color = factor(vs))) +
  geom_boxplot()
```

### Задача

При помощи функции ggplot() или boxplot() постройте график boxplot, используя встроенные в R данные airquality. По оси x отложите номер месяца, по оси y — значения переменной Ozone.

На графике boxplot отдельными точками отображаются наблюдения, отклоняющиеся от 1 или 3 квартиля больше чем на полтора межквартильных размаха. Сколько таких наблюдений присутствует в сентябре (месяц №9)?

```{r}
ggplot(airquality, aes(factor(Month), Ozone)) +
  geom_boxplot()
```


### Задача

Используем знакомые нам данные mtcars. 

Нужно построить scatterplot с помощью ggplot из ggplot2, по оси x которого будет mpg, по оси y - disp, а цветом отобразить переменную (hp).

Полученный график нужно сохранить в переменную plot1. Таким образом в ответе должен быть скрипт:

```{r}
plot1 <- ggplot(mtcars, aes(mpg, disp, color = hp)) +
  geom_point()
```

### Задача

Немного гистограмм с ирисами

```{r}
ggplot(iris, aes(Sepal.Length, fill = Species)) + geom_histogram()
ggplot(iris, aes(Sepal.Length)) + geom_histogram(aes(fill = Species))
```

### Задача

Студент Ярослав очень любит строить графики в R. Основываясь на данных iris он хочет построить следующий график:

Scatterplot (диаграмма рассеивания), где по оси X будет отложена переменная Sepal.Length,  по оси Y переменная  Sepal.Width. За цвет точек будет отвечать переменная  Species, а за размер точек переменная Petal.Length.


```{r}
ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species, size = Petal.Length)) +
  geom_point()

ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point(aes(color = Species, size = Petal.Length))
```

## Анализ номинативных данных

Данные для работы на этом уроке

```{r}
df <- read_csv("grants.csv")

# сделаем замены на фактор и понятные описания
df$status <- as.factor(df$status)
levels(df$status) <- c("Not funded", "Funded")

df$status <- factor(df$status, labels = c("Not funded", "Funded"))

str(df)

# 1d table
t1 <-  table(df$status)

# 2d table
t2 <- table(df$status, df$field)

prop.table(t2)

# 3d table

t3 <- table(Years = df$years_in_uni, Field = df$field, Status = df$status)

dim(t3)
```

### Задача

Ваша задача в переменную red_men сохранить долю рыжеволосых (Red) от общего числа голубоглазых мужчин.

```{r}
HairEyeColor
dimnames(HairEyeColor)

# only man
prop.table(HairEyeColor[ , ,'Male'], 2)['Red', 'Blue']
```

* создаем двумерную таблицу, 2- группировка значений по столбцу `prop.table(HairEyeColor[ , ,'Male'], 2)`

* обращаемся к ее х/у `['Red', 'Blue']`

### Задача

Напишите число зеленоглазых женщин в наборе данных HairEyeColor.

```{r}

```

